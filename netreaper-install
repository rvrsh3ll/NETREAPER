#!/usr/bin/env bash
#═══════════════════════════════════════════════════════════════════════════════
#
#    NETREAPER ARSENAL INSTALLER v2.0
#    Premium tool installation experience
#
#    Copyright (c) 2025 OFFTRACKMEDIA Studios
#    Licensed under the Apache License, Version 2.0
#
#═══════════════════════════════════════════════════════════════════════════════

set -o pipefail

readonly VERSION="2.0.0"
readonly SCRIPT_NAME="netreaper-install"

# Colors
readonly C_RESET='\033[0m'
readonly C_RED='\033[38;5;196m'
readonly C_GREEN='\033[38;5;46m'
readonly C_YELLOW='\033[38;5;226m'
readonly C_CYAN='\033[38;5;51m'
readonly C_BLUE='\033[38;5;39m'
readonly C_SHADOW='\033[38;5;244m'

# Logging
log_info()    { echo -e "    ${C_CYAN}[*]${C_RESET} $*"; }
log_success() { echo -e "    ${C_GREEN}[✓]${C_RESET} $*"; }
log_warning() { echo -e "    ${C_YELLOW}[!]${C_RESET} $*"; }
log_error()   { echo -e "    ${C_RED}[✗]${C_RESET} $*"; }
log_verbose() { [[ -n "${VERBOSE:-}" ]] && echo -e "    ${C_SHADOW}[-]${C_RESET} $*"; }

# Global tracking
declare -a FAILED_TOOLS=()
declare -a SKIPPED_TOOLS=()
declare -a INSTALL_ATTEMPTED=()
declare -a ALL_FAILED_TOOLS=()
declare -a ALL_SKIPPED_TOOLS=()
declare -a ALL_INSTALL_ATTEMPTED=()
INSTALL_ERRORS=0

# Error handler (non-fatal)
handle_error() {
    local tool="$1"
    local method="$2"
    local exit_code="$3"

    FAILED_TOOLS+=("$tool:$method:$exit_code")
    ((INSTALL_ERRORS++))

    log_warning "$tool installation failed ($method, exit code: $exit_code)"
    return 0
}

# Tool definitions
# Format: [tool]="binary:package:primary_method:fallback_method"
declare -A TOOLS=(
    # SCANNING
    [nmap]="nmap:nmap:apt:-"
    [masscan]="masscan:masscan:apt:-"
    [rustscan]="rustscan:RustScan/RustScan:github:-"
    [zmap]="zmap:zmap:apt:-"
    [arp-scan]="arp-scan:arp-scan:apt:-"
    [netdiscover]="netdiscover:netdiscover:apt:-"
    [hping3]="hping3:hping3:apt:-"
    [fping]="fping:fping:apt:-"

    # WIRELESS
    [aircrack-ng]="aircrack-ng:aircrack-ng:apt:-"
    [reaver]="reaver:reaver:apt:-"
    [bully]="bully:bully:apt:-"
    [pixiewps]="pixiewps:pixiewps:apt:-"
    [wifite]="wifite:wifite:apt:pip"
    [bettercap]="bettercap:bettercap:apt:github"
    [mdk3]="mdk3:mdk3:apt:-"
    [mdk4]="mdk4:mdk4:apt:-"
    [hostapd]="hostapd:hostapd:apt:-"
    [cowpatty]="cowpatty:cowpatty:apt:-"

    # WEB
    [nikto]="nikto:nikto:apt:-"
    [sqlmap]="sqlmap:sqlmap:apt:pip"
    [dirb]="dirb:dirb:apt:-"
    [gobuster]="gobuster:gobuster:apt:go"
    [ffuf]="ffuf:ffuf:apt:go"
    [wpscan]="wpscan:wpscan:gem:apt"
    [nuclei]="nuclei:projectdiscovery/nuclei:github:go"
    [httpx]="httpx:projectdiscovery/httpx:github:go"
    [subfinder]="subfinder:projectdiscovery/subfinder:github:go"
    [amass]="amass:owasp-amass/amass:github:snap"

    # EXPLOIT
    [metasploit-framework]="msfconsole:metasploit-framework:apt:-"
    [exploitdb]="searchsploit:exploitdb:apt:-"
    [crackmapexec]="crackmapexec:crackmapexec:pipx:pip"

    # OSINT
    [theharvester]="theHarvester:theHarvester:apt:pip"
    [recon-ng]="recon-ng:recon-ng:apt:pip"
    [maltego]="maltego:maltego:apt:-"
    [shodan]="shodan:shodan:pip:-"

    # CREDENTIALS
    [hashcat]="hashcat:hashcat:apt:-"
    [john]="john:john:apt:-"
    [hydra]="hydra:hydra:apt:-"
    [medusa]="medusa:medusa:apt:-"

    # TRAFFIC
    [tcpdump]="tcpdump:tcpdump:apt:-"
    [wireshark]="wireshark:wireshark:apt:-"
    [tshark]="tshark:tshark:apt:-"
    [ettercap]="ettercap:ettercap-common:apt:-"
)

# Categories
declare -A CATEGORIES=(
    [scanning]="nmap masscan rustscan zmap arp-scan netdiscover hping3 fping"
    [wireless]="aircrack-ng reaver bully pixiewps wifite bettercap mdk3 mdk4 hostapd cowpatty"
    [web]="nikto sqlmap dirb gobuster wpscan ffuf nuclei httpx subfinder amass"
    [exploit]="metasploit-framework exploitdb crackmapexec"
    [osint]="theharvester recon-ng maltego shodan"
    [creds]="hashcat john hydra medusa"
    [traffic]="tcpdump wireshark tshark ettercap"
)

check_tool_installed() {
    local tool="$1"
    local info="${TOOLS[$tool]:-}"
    local binary="$tool"

    if [[ -n "$info" ]]; then
        binary=$(echo "$info" | cut -d: -f1)
    fi

    for bin in $binary; do
        if command -v "$bin" &>/dev/null; then
            return 0
        fi
    done

    [[ -f "/opt/$tool/$tool" ]] && return 0
    [[ -f "/opt/$tool/${tool}.sh" ]] && return 0
    [[ -d "/opt/$tool" ]] && return 0
    [[ -f "/usr/share/$tool/$tool" ]] && return 0

    return 1
}

# Pre-flight checks
preflight_checks() {
    echo -e "    ${C_CYAN}[*]${C_RESET} Running pre-flight checks..."

    if [[ $EUID -ne 0 ]]; then
        echo -e "    ${C_RED}[!]${C_RESET} This installer requires root privileges"
        echo -e "    ${C_SHADOW}    Run: sudo $SCRIPT_NAME${C_RESET}"
        exit 1
    fi

    if ! ping -c 1 -W 3 8.8.8.8 &>/dev/null; then
        echo -e "    ${C_YELLOW}[!]${C_RESET} No internet connection detected"
        echo -e "    ${C_SHADOW}    Some installations may fail${C_RESET}"
    fi

    echo -ne "    ${C_CYAN}[*]${C_RESET} Updating package lists..."
    apt-get update &>/dev/null
    echo -e "\r    ${C_GREEN}[✓]${C_RESET} Package lists updated    "

    echo -ne "    ${C_CYAN}[*]${C_RESET} Installing base dependencies..."
    apt-get install -y curl wget git unzip jq &>/dev/null
    echo -e "\r    ${C_GREEN}[✓]${C_RESET} Base dependencies ready  "

    if ! command -v pip3 &>/dev/null; then
        apt-get install -y python3-pip &>/dev/null
    fi

    if ! command -v pipx &>/dev/null; then
        apt-get install -y pipx &>/dev/null || \
        pip3 install pipx --break-system-packages &>/dev/null
    fi

    echo -e "    ${C_GREEN}[✓]${C_RESET} Pre-flight checks complete"
    echo
}

# Install helpers
install_apt() {
    local package="$1"
    DEBIAN_FRONTEND=noninteractive apt-get install -y "$package" &>/dev/null
}

install_pip() {
    local package="$1"
    pip3 install "$package" --user --break-system-packages &>/dev/null || \
    pip3 install "$package" --user &>/dev/null || \
    pip install "$package" --user &>/dev/null
}

install_pipx() {
    local package="$1"
    command -v pipx &>/dev/null || {
        apt-get install -y pipx &>/dev/null || \
        pip3 install pipx --user --break-system-packages &>/dev/null
    }
    pipx install "$package" &>/dev/null || \
    pipx install "$package" --force &>/dev/null
}

install_gem() {
    local package="$1"
    command -v gem &>/dev/null || apt-get install -y ruby ruby-dev &>/dev/null
    gem install "$package" --no-document &>/dev/null
}

install_go() {
    local package="$1"
    command -v go &>/dev/null || apt-get install -y golang-go &>/dev/null
    go install "$package"@latest &>/dev/null
}

install_snap() {
    local package="$1"
    command -v snap &>/dev/null || return 1
    snap install "$package" &>/dev/null || \
    snap install "$package" --classic &>/dev/null
}

install_flatpak() {
    local package="$1"
    command -v flatpak &>/dev/null || return 1
    flatpak install -y flathub "$package" &>/dev/null
}

install_github() {
    local tool="$1"
    local repo="$2"
    local api_url="https://api.github.com/repos/$repo/releases/latest"
    local release_json

    release_json=$(curl -sL --connect-timeout 10 --max-time 30 "$api_url") || return 1

    local download_url
    download_url=$(echo "$release_json" | grep -oP '"browser_download_url":\s*"\K[^"]+' | \
        grep -iE 'linux.*amd64|linux.*x86_64|linux64|amd64\.deb' | \
        grep -vE '\.sha256|\.sig|\.asc' | head -1)

    [[ -z "$download_url" ]] && return 1

    local tmp_file="/tmp/${tool}_download_$$"
    curl -sL --connect-timeout 10 --max-time 120 "$download_url" -o "$tmp_file" || return 1

    case "$download_url" in
        *.deb)
            dpkg -i "$tmp_file" &>/dev/null
            apt-get install -f -y &>/dev/null
            ;;
        *.tar.gz|*.tgz)
            local extract_dir="/tmp/${tool}_extract_$$"
            mkdir -p "$extract_dir"
            tar -xzf "$tmp_file" -C "$extract_dir" &>/dev/null
            local binary
            binary=$(find "$extract_dir" -type f -executable -name "*$tool*" 2>/dev/null | head -1)
            [[ -z "$binary" ]] && binary=$(find "$extract_dir" -type f -executable 2>/dev/null | head -1)
            [[ -n "$binary" ]] && install -m 755 "$binary" /usr/local/bin/"$tool"
            rm -rf "$extract_dir"
            ;;
        *.zip)
            local extract_dir="/tmp/${tool}_extract_$$"
            mkdir -p "$extract_dir"
            unzip -q "$tmp_file" -d "$extract_dir" &>/dev/null
            local binary
            binary=$(find "$extract_dir" -type f -executable -name "*$tool*" 2>/dev/null | head -1)
            [[ -z "$binary" ]] && binary=$(find "$extract_dir" -type f -executable 2>/dev/null | head -1)
            [[ -n "$binary" ]] && install -m 755 "$binary" /usr/local/bin/"$tool"
            rm -rf "$extract_dir"
            ;;
        *)
            install -m 755 "$tmp_file" /usr/local/bin/"$tool"
            ;;
    esac

    rm -f "$tmp_file"
    command -v "$tool" &>/dev/null
}

install_git() {
    local tool="$1"
    local repo="$2"
    local install_dir="/opt/$tool"

    rm -rf "$install_dir"
    git clone --depth 1 "https://github.com/$repo.git" "$install_dir" &>/dev/null || return 1

    if [[ -f "$install_dir/setup.py" ]]; then
        (cd "$install_dir" && pip3 install . &>/dev/null)
    elif [[ -f "$install_dir/requirements.txt" ]]; then
        pip3 install -r "$install_dir/requirements.txt" &>/dev/null
    fi

    for script in "$tool" "$tool.py" "main.py" "${tool}.sh"; do
        if [[ -f "$install_dir/$script" ]]; then
            chmod +x "$install_dir/$script"
            ln -sf "$install_dir/$script" /usr/local/bin/"$tool" 2>/dev/null
            break
        fi
    done

    return 0
}

install_script() {
    local tool="$1"
    local script_url="$2"
    curl -sL "$script_url" | bash &>/dev/null
}

# Tool-specific installers
install_wpscan() {
    if command -v gem &>/dev/null; then
        apt-get install -y ruby ruby-dev libcurl4-openssl-dev make &>/dev/null
        gem install wpscan --no-document &>/dev/null && return 0
    fi

    apt-get install -y wpscan &>/dev/null && return 0

    if command -v docker &>/dev/null; then
        docker pull wpscanteam/wpscan &>/dev/null
        cat > /usr/local/bin/wpscan <<'EOF'
#!/bin/bash
docker run -it --rm wpscanteam/wpscan "$@"
EOF
        chmod +x /usr/local/bin/wpscan
        return 0
    fi

    return 1
}

install_amass() {
    local repo="owasp-amass/amass"
    install_github "amass" "$repo" && return 0

    if command -v snap &>/dev/null; then
        snap install amass &>/dev/null && return 0
    fi

    if command -v go &>/dev/null; then
        go install github.com/owasp-amass/amass/v4/...@latest &>/dev/null && return 0
    fi

    apt-get install -y amass &>/dev/null && return 0
    return 1
}

install_crackmapexec() {
    if command -v pipx &>/dev/null || pip3 install pipx --user --break-system-packages &>/dev/null; then
        pipx install git+https://github.com/Pennyw0rth/NetExec &>/dev/null && {
            ln -sf ~/.local/bin/netexec /usr/local/bin/crackmapexec 2>/dev/null
            return 0
        }
    fi

    pip3 install git+https://github.com/Pennyw0rth/NetExec --break-system-packages &>/dev/null && return 0
    apt-get install -y crackmapexec &>/dev/null && return 0
    return 1
}

install_shodan() {
    pip3 install shodan --user --break-system-packages &>/dev/null || \
    pip3 install shodan --user &>/dev/null || \
    pip install shodan --user &>/dev/null

    export PATH="$HOME/.local/bin:$PATH"
    command -v shodan &>/dev/null
}

install_theharvester() {
    apt-get install -y theharvester &>/dev/null && return 0

    pip3 install theHarvester --break-system-packages &>/dev/null && return 0

    local install_dir="/opt/theHarvester"
    rm -rf "$install_dir"
    git clone --depth 1 https://github.com/laramies/theHarvester.git "$install_dir" &>/dev/null || return 1
    (cd "$install_dir" && pip3 install -r requirements.txt --break-system-packages &>/dev/null)
    ln -sf "$install_dir/theHarvester.py" /usr/local/bin/theharvester
    chmod +x /usr/local/bin/theharvester
    return 0
}

install_recon_ng() {
    apt-get install -y recon-ng &>/dev/null && return 0

    local install_dir="/opt/recon-ng"
    rm -rf "$install_dir"
    git clone --depth 1 https://github.com/lanmaster53/recon-ng.git "$install_dir" &>/dev/null || return 1
    (cd "$install_dir" && pip3 install -r REQUIREMENTS --break-system-packages &>/dev/null)
    ln -sf "$install_dir/recon-ng" /usr/local/bin/recon-ng
    chmod +x /usr/local/bin/recon-ng
    return 0
}

install_rustscan() {
    local repo="RustScan/RustScan"
    local api_url="https://api.github.com/repos/$repo/releases/latest"
    local download_url
    download_url=$(curl -sL "$api_url" | grep -oP '"browser_download_url":\s*"\K[^\"]+\.deb' | head -1)

    if [[ -n "$download_url" ]]; then
        local tmp_file="/tmp/rustscan.deb"
        curl -sL "$download_url" -o "$tmp_file" && \
        dpkg -i "$tmp_file" &>/dev/null && \
        apt-get install -f -y &>/dev/null && \
        rm -f "$tmp_file" && \
        return 0
    fi

    if command -v cargo &>/dev/null; then
        cargo install rustscan &>/dev/null && return 0
    fi

    return 1
}

try_install() {
    local tool="$1"
    local package="$2"
    local method="$3"

    case "$tool" in
        wpscan) install_wpscan && return 0 ;; 
        amass) install_amass && return 0 ;;
        crackmapexec) install_crackmapexec && return 0 ;;
        shodan) install_shodan && return 0 ;;
        theharvester) install_theharvester && return 0 ;;
        recon-ng) install_recon_ng && return 0 ;;
        rustscan) install_rustscan && return 0 ;;
    esac

    case "$method" in
        apt)       install_apt "$package" ;;
        pip)       install_pip "$package" ;;
        pipx)      install_pipx "$package" ;;
        gem)       install_gem "$package" ;;
        go)        install_go "$package" ;;
        snap)      install_snap "$package" ;;
        flatpak)   install_flatpak "$package" ;;
        github)    install_github "$tool" "$package" ;;
        git)       install_git "$tool" "$package" ;;
        script)    install_script "$tool" "$package" ;;
        *)         return 1 ;;
    esac
}

install_tool() {
    local tool="$1"
    local info="${TOOLS[$tool]:-}"

    if [[ -z "$info" ]]; then
        log_warning "Unknown tool: $tool"
        SKIPPED_TOOLS+=("$tool:unknown")
        return 0
    fi

    if check_tool_installed "$tool"; then
        echo -e "    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(already installed)${C_RESET}"
        return 0
    fi

    echo -ne "    ${C_CYAN}○${C_RESET} Installing $tool..."

    local binary package primary_method fallback_method
    binary=$(echo "$info" | cut -d: -f1)
    package=$(echo "$info" | cut -d: -f2)
    primary_method=$(echo "$info" | cut -d: -f3)
    fallback_method=$(echo "$info" | cut -d: -f4)

    if try_install "$tool" "$package" "$primary_method"; then
        echo -e "\r    ${C_GREEN}✓${C_RESET} $tool                    "
        return 0
    fi
    handle_error "$tool" "$primary_method" "$?"

    if [[ -n "$fallback_method" && "$fallback_method" != "-" ]]; then
        log_verbose "Primary failed, trying fallback: $fallback_method"
        if try_install "$tool" "$package" "$fallback_method"; then
            echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(fallback)${C_RESET}          "
            return 0
        fi
        handle_error "$tool" "$fallback_method" "$?"
    fi

    for method in apt snap flatpak pip pipx gem go github; do
        [[ "$method" == "$primary_method" ]] && continue
        [[ "$method" == "$fallback_method" ]] && continue
        if try_install "$tool" "$package" "$method" 2>/dev/null; then
            echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}($method)${C_RESET}          "
            return 0
        fi
    done

    echo -e "\r    ${C_RED}✗${C_RESET} $tool ${C_SHADOW}(all methods failed)${C_RESET}"
    FAILED_TOOLS+=("$tool")
    ((INSTALL_ERRORS++))
    return 0
}

show_install_summary() {
    echo
    echo -e "    ${C_CYAN}═══════════════════════════════════════════════════════════════${C_RESET}"
    echo -e "    ${C_RED}                    INSTALLATION SUMMARY${C_RESET}"
    echo -e "    ${C_CYAN}═══════════════════════════════════════════════════════════════${C_RESET}"
    echo

    local total_attempted=${#INSTALL_ATTEMPTED[@]}
    local total_success=$((total_attempted - ${#FAILED_TOOLS[@]}))

    echo -e "    ${C_GREEN}✓ Successful:${C_RESET} $total_success"
    echo -e "    ${C_RED}✗ Failed:${C_RESET}     ${#FAILED_TOOLS[@]}"
    echo -e "    ${C_SHADOW}○ Skipped:${C_RESET}    ${#SKIPPED_TOOLS[@]}"
    echo

    if [[ ${#FAILED_TOOLS[@]} -gt 0 ]]; then
        echo -e "    ${C_RED}Failed tools:${C_RESET}"
        for tool in "${FAILED_TOOLS[@]}"; do
            echo -e "      ${C_RED}•${C_RESET} $tool"
        done
        echo
        echo -e "    ${C_SHADOW}Try installing manually or check network connection.${C_RESET}"
        echo -e "    ${C_SHADOW}Some tools require Kali/Parrot repos or specific dependencies.${C_RESET}"
    fi

    echo
}

install_category() {
    local category="$1"
    local tools="${CATEGORIES[$category]:-}"

    if [[ -z "$tools" ]]; then
        log_error "Unknown category: $category"
        return 1
    fi

    echo
    echo -e "    ${C_CYAN}━━━ Installing ${category^^} tools ━━━${C_RESET}"

    FAILED_TOOLS=()
    SKIPPED_TOOLS=()
    INSTALL_ATTEMPTED=()

    for tool in $tools; do
        INSTALL_ATTEMPTED+=("$tool")
        install_tool "$tool" || true
    done

    ALL_FAILED_TOOLS+=("${FAILED_TOOLS[@]}")
    ALL_SKIPPED_TOOLS+=("${SKIPPED_TOOLS[@]}")
    ALL_INSTALL_ATTEMPTED+=("${INSTALL_ATTEMPTED[@]}")

    if [[ ${#FAILED_TOOLS[@]} -gt 0 ]]; then
        echo -e "    ${C_YELLOW}⚠${C_RESET} ${#FAILED_TOOLS[@]} tool(s) failed in ${category^^}"
    fi

    return 0
}

install_all() {
    local all_failed=()
    local all_skipped=()
    local all_attempted=()

    for category in scanning wireless web exploit osint creds traffic; do
        install_category "$category" || true
        all_failed+=("${FAILED_TOOLS[@]}")
        all_skipped+=("${SKIPPED_TOOLS[@]}")
        all_attempted+=("${INSTALL_ATTEMPTED[@]}")
        FAILED_TOOLS=()
        SKIPPED_TOOLS=()
        INSTALL_ATTEMPTED=()
    done

    FAILED_TOOLS=("${all_failed[@]}")
    SKIPPED_TOOLS=("${all_skipped[@]}")
    INSTALL_ATTEMPTED=("${all_attempted[@]}")

    show_install_summary
}

install_essentials() {
    local essentials="nmap masscan aircrack-ng hashcat john hydra nikto gobuster sqlmap tcpdump wireshark netdiscover arp-scan"
    CATEGORIES[essentials]="$essentials"
    install_category "essentials"
    show_install_summary
}

show_status() {
    echo
    echo -e "    ${C_BLUE}━━━ ARSENAL STATUS ━━━${C_RESET}"
    echo

    local installed=0
    local missing=0

    for category in "${!CATEGORIES[@]}"; do
        echo -e "    ${C_CYAN}${category^^}:${C_RESET}"
        echo -n "    "
        for tool in ${CATEGORIES[$category]}; do
            if check_tool_installed "$tool"; then
                echo -ne "${C_GREEN}✓${C_RESET}${tool}  "
                ((installed++))
            else
                echo -ne "${C_RED}✗${C_RESET}${tool}  "
                ((missing++))
            fi
        done
        echo
    done

    echo
    echo -e "    ${C_GREEN}Installed: $installed${C_RESET}  ${C_RED}Missing: $missing${C_RESET}"
}

show_menu() {
    while true; do
        clear
        echo
        echo -e "    ${C_RED}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_RED}║${C_RESET}           ${C_CYAN}NETREAPER ARSENAL INSTALLER${C_RESET}                    ${C_RED}║${C_RESET}"
        echo -e "    ${C_RED}╚═══════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[1]${C_RESET} Install ALL tools      ${C_SHADOW}(~3-5GB, 15-30 min)${C_RESET}"
        echo -e "    ${C_SHADOW}[2]${C_RESET} Install essentials     ${C_SHADOW}(~500MB, 5 min)${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[3]${C_RESET} Install SCANNING       ${C_SHADOW}nmap, masscan, rustscan...${C_RESET}"
        echo -e "    ${C_SHADOW}[4]${C_RESET} Install WIRELESS       ${C_SHADOW}aircrack-ng, wifite, bettercap...${C_RESET}"
        echo -e "    ${C_SHADOW}[5]${C_RESET} Install WEB            ${C_SHADOW}nikto, sqlmap, gobuster...${C_RESET}"
        echo -e "    ${C_SHADOW}[6]${C_RESET} Install EXPLOIT        ${C_SHADOW}metasploit, searchsploit...${C_RESET}"
        echo -e "    ${C_SHADOW}[7]${C_RESET} Install CREDENTIALS    ${C_SHADOW}hashcat, john, hydra...${C_RESET}"
        echo -e "    ${C_SHADOW}[8]${C_RESET} Install OSINT          ${C_SHADOW}theharvester, recon-ng...${C_RESET}"
        echo -e "    ${C_SHADOW}[9]${C_RESET} Install TRAFFIC        ${C_SHADOW}tcpdump, wireshark...${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[S]${C_RESET} Show status"
        echo -e "    ${C_SHADOW}[Q]${C_RESET} Quit"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice

        case "$choice" in
            1) preflight_checks; install_all ;;
            2) preflight_checks; install_essentials ;;
            3) preflight_checks; install_category "scanning"; show_install_summary ;;
            4) preflight_checks; install_category "wireless"; show_install_summary ;;
            5) preflight_checks; install_category "web"; show_install_summary ;;
            6) preflight_checks; install_category "exploit"; show_install_summary ;;
            7) preflight_checks; install_category "creds"; show_install_summary ;;
            8) preflight_checks; install_category "osint"; show_install_summary ;;
            9) preflight_checks; install_category "traffic"; show_install_summary ;;
            s|S) show_status ;;
            q|Q) exit 0 ;;
            *) log_error "Invalid option" ;;
        esac

        echo
        echo -ne "    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

show_usage() {
    echo "NETREAPER Arsenal Installer v${VERSION}"
    echo
    echo "Usage: sudo $SCRIPT_NAME [command]"
    echo
    echo "Commands:"
    echo "    all          Install all tools"
    echo "    essentials   Install essential tools only"
    echo "    scanning     Install scanning tools"
    echo "    wireless     Install wireless tools"
    echo "    web          Install web tools"
    echo "    exploit      Install exploit tools"
    echo "    creds        Install credential tools"
    echo "    osint        Install OSINT tools"
    echo "    traffic      Install traffic tools"
    echo "    status       Show installation status"
    echo "    menu         Interactive menu (default)"
    echo
}

main() {
    case "${1:-menu}" in
        all)
            preflight_checks
            install_all
            ;;
        essentials)
            preflight_checks
            install_essentials
            ;;
        scanning)
            preflight_checks
            install_category "scanning"
            show_install_summary
            ;;
        wireless)
            preflight_checks
            install_category "wireless"
            show_install_summary
            ;;
        web)
            preflight_checks
            install_category "web"
            show_install_summary
            ;;
        exploit)
            preflight_checks
            install_category "exploit"
            show_install_summary
            ;;
        creds)
            preflight_checks
            install_category "creds"
            show_install_summary
            ;;
        osint)
            preflight_checks
            install_category "osint"
            show_install_summary
            ;;
        traffic)
            preflight_checks
            install_category "traffic"
            show_install_summary
            ;;
        status)
            show_status
            ;;
        menu|"")
            show_menu
            ;;
        -h|--help)
            show_usage
            ;;
        *)
            log_error "Unknown command: $1"
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
